{"version":3,"sources":["cfs:worker/fileWorker.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAAA,oD;AACA,gF;AACA,gB;;AAEA,G;AACA,U;AACA,e;AACA,G;AACA,mB;;AAEA,G;AACA,gC;AACA,U;AACA,sC;AACA,uB;AACA,E;AACA,uE;AACA,uC;AACA,G;AACA,gD;;AAEA,mF;AACA,e;AACA,gE;AACA,+B;AACA,uD;AACA,e;AACA,iB;AACA,O;AACA,gB;AACA,+B;AACA,uC;AACA,qG;AACA,oC;AACA,Q;AACA,iC;AACA,qD;AACA,uG;AACA,oC;AACA,O;AACA,O;AACA,K;;AAEA,8E;AACA,mB;AACA,8E;AACA,6B;AACA,yF;AACA,sC;AACA,K;AACA,K;;AAEA,mE;AACA,8C;AACA,qC;AACA,+B;AACA,+F;AACA,8B;AACA,sC;AACA,8B;AACA,sE;AACA,uC;AACA,S;AACA,K;AACA,K;AACA,E;;AAEA,G;AACA,yB;AACA,Y;AACA,gE;AACA,E;AACA,+D;AACA,0D;AACA,oB;AACA,E;AACA,K;AACA,kC;AACA,+B;AACA,yD;AACA,K;AACA,G;AACA,mC;AACA,+C;AACA,yC;AACA,yE;AACA,kB;AACA,C;;AAEA,G;AACA,wB;AACA,Y;AACA,2E;AACA,E;AACA,oE;AACA,oD;AACA,qE;AACA,kC;AACA,E;AACA,K;AACA,a;AACA,kC;AACA,S;AACA,gB;AACA,a;AACA,qB;AACA,iB;AACA,iD;AACA,kB;AACA,iB;AACA,kD;AACA,iB;AACA,e;AACA,c;AACA,a;AACA,0D;AACA,a;AACA,W;AACA,U;AACA,+B;AACA,O;AACA,K;AACA,E;AACA,G;AACA,+B;AACA,kB;AACA,Y;AACA,I;;AAEA,0C;AACA,2C;AACA,+B;AACA,uC;AACA,sB;AACA,kD;AACA,wC;AACA,kB;AACA,mD;AACA,wC;AACA,kB;AACA,oE;AACA,gC;AACA,iC;AACA,I;;AAEA,kB;AACA,C;;AAEA,G;AACA,mB;AACA,W;AACA,0B;AACA,4B;AACA,0B;AACA,kF;AACA,uB;AACA,E;AACA,uC;AACA,0E;AACA,wE;AACA,G;AACA,+C;AACA,0B;;AAEA,6C;AACA,iB;AACA,iE;AACA,G;;AAEA,0D;;AAEA,8D;AACA,yD;;AAEA,gD;AACA,+B;AACA,C","file":"/packages/cfs:worker.js","sourcesContent":["//// TODO: Use power queue to handle throttling etc.\n//// Use observe to monitor changes and have it create tasks for the power queue\n//// to perform.\n\n/**\n * @public\n * @type Object\n */\nFS.FileWorker = {};\n\n/**\n * @method FS.FileWorker.observe\n * @public\n * @param {FS.Collection} fsCollection\n * @returns {undefined}\n *\n * Sets up observes on the fsCollection to store file copies and delete\n * temp files at the appropriate times.\n */\nFS.FileWorker.observe = function(fsCollection) {\n\n  // Initiate observe for finding newly uploaded/added files that need to be stored\n  // per store.\n  FS.Utility.each(fsCollection.options.stores, function(store) {\n    var storeName = store.name;\n    fsCollection.files.find(getReadyQuery(storeName), {\n      fields: {\n        copies: 0\n      }\n    }).observe({\n      added: function(fsFile) {\n        // added will catch fresh files\n        FS.debug && console.log(\"FileWorker ADDED - calling saveCopy\", storeName, \"for\", fsFile._id);\n        saveCopy(fsFile, storeName);\n      },\n      changed: function(fsFile) {\n        // changed will catch failures and retry them\n        FS.debug && console.log(\"FileWorker CHANGED - calling saveCopy\", storeName, \"for\", fsFile._id);\n        saveCopy(fsFile, storeName);\n      }\n    });\n  });\n\n  // Initiate observe for finding files that have been stored so we can delete\n  // any temp files\n  fsCollection.files.find(getDoneQuery(fsCollection.options.stores)).observe({\n    added: function(fsFile) {\n      FS.debug && console.log(\"FileWorker ADDED - calling deleteChunks for\", fsFile._id);\n      FS.TempStore.removeFile(fsFile);\n    }\n  });\n\n  // Initiate observe for catching files that have been removed and\n  // removing the data from all stores as well\n  fsCollection.files.find().observe({\n    removed: function(fsFile) {\n      FS.debug && console.log('FileWorker REMOVED - removing all stored data for', fsFile._id);\n      //remove from temp store\n      FS.TempStore.removeFile(fsFile);\n      //delete from all stores\n      FS.Utility.each(fsCollection.options.stores, function(storage) {\n        storage.adapter.remove(fsFile);\n      });\n    }\n  });\n};\n\n/**\n *  @method getReadyQuery\n *  @private\n *  @param {string} storeName - The name of the store to observe\n *\n *  Returns a selector that will be used to identify files that\n *  have been uploaded but have not yet been stored to the\n *  specified store.\n *\n *  {\n *    uploadedAt: {$exists: true},\n *    'copies.storeName`: null,\n *    'failures.copies.storeName.doneTrying': {$ne: true}\n *  }\n */\nfunction getReadyQuery(storeName) {\n  var selector = {uploadedAt: {$exists: true}};\n  selector['copies.' + storeName] = null;\n  selector['failures.copies.' + storeName + '.doneTrying'] = {$ne: true};\n  return selector;\n}\n\n/**\n *  @method getDoneQuery\n *  @private\n *  @param {Array} stores - The stores array from the FS.Collection options\n *\n *  Returns a selector that will be used to identify files where all\n *  stores have successfully save or have failed the\n *  max number of times but still have chunks. The resulting selector\n *  should be something like this:\n *\n *  {\n *    $and: [\n *      {chunks: {$exists: true}},\n *      {\n *        $or: [\n *          {\n *            $and: [\n *              {\n *                'copies.storeName': {$ne: null}\n *              },\n *              {\n *                'copies.storeName': {$ne: false}\n *              }\n *            ]\n *          },\n *          {\n *            'failures.copies.storeName.doneTrying': true\n *          }\n *        ]\n *      },\n *      REPEATED FOR EACH STORE\n *    ]\n *  }\n *\n */\nfunction getDoneQuery(stores) {\n  var selector = {\n    $and: []\n  };\n\n  // Add conditions for all defined stores\n  FS.Utility.each(stores, function(store) {\n    var storeName = store.name;\n    var copyCond = {$or: [{$and: []}]};\n    var tempCond = {};\n    tempCond[\"copies.\" + storeName] = {$ne: null};\n    copyCond.$or[0].$and.push(tempCond);\n    tempCond = {};\n    tempCond[\"copies.\" + storeName] = {$ne: false};\n    copyCond.$or[0].$and.push(tempCond);\n    tempCond = {};\n    tempCond['failures.copies.' + storeName + '.doneTrying'] = true;\n    copyCond.$or.push(tempCond);\n    selector.$and.push(copyCond);\n  })\n\n  return selector;\n}\n\n/**\n * @method saveCopy\n * @private\n * @param {FS.File} fsFile\n * @param {string} storeName\n * @param {Object} options\n * @param {Boolean} [options.overwrite=false] - Force save to the specified store?\n * @returns {undefined}\n *\n * Saves to the specified store. If the\n * `overwrite` option is `true`, will save to the store even if we already\n * have, potentially overwriting any previously saved data. Synchronous.\n */\nfunction saveCopy(fsFile, storeName, options) {\n  options = options || {};\n\n  var storage = FS.StorageAdapter(storeName);\n  if (!storage) {\n    throw new Error('No store named \"' + storeName + '\" exists');\n  }\n\n  FS.debug && console.log('saving to store ' + storeName);\n\n  var writeStream = storage.adapter.createWriteStream(fsFile);\n  var readStream = FS.TempStore.createReadStream(fsFile);\n\n  // Pipe the temp data into the storage adapter\n  readStream.pipe(writeStream);\n}\n"]}