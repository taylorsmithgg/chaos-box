{"version":3,"file":"/packages/cfs:reactive-list.js","sources":["cfs:reactive-list/reactive-list.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA,gB;AACA,4C;AACA,kC;;AAEA,oB;AACA,yB;AACA,uB;AACA,E;;AAEA,iE;AACA,gB;AACA,2B;AACA,6B;AACA,oD;AACA,2E;AACA,Y;AACA,S;AACA,oC;AACA,8C;AACA,8C;AACA,8C;AACA,2C;AACA,qB;AACA,G;AACA,yC;AACA,0C;AACA,yE;AACA,G;AACA,8B;AACA,wC;AACA,4B;AACA,Q;AACA,O;AACA,G;AACA,mC;AACA,oD;AACA,S;AACA,mC;AACA,8B;AACA,+C;AACA,qC;AACA,+B;AACA,S;AACA,S;AACA,O;AACA,mB;AACA,O;AACA,8D;AACA,gF;AACA,qE;AACA,O;AACA,I;AACA,kC;AACA,kB;AACA,qB;AACA,mB;AACA,W;AACA,mB;AACA,yB;AACA,a;AACA,wB;AACA,Y;AACA,sD;AACA,0D;AACA,yB;AACA,K;;AAEA,mD;AACA,iE;;AAEA,kB;AACA,6D;AACA,yD;AACA,G;;AAEA,yB;AACA,2E;;AAEA,6E;AACA,E;;AAEA,wE;AACA,a;AACA,iD;AACA,I;AACA,4C;AACA,kB;AACA,uB;AACA,4B;AACA,sB;AACA,E;;AAEA,iE;AACA,2F;AACA,I;AACA,2C;AACA,kB;AACA,4C;AACA,yB;AACA,2C;AACA,wB;AACA,4B;AACA,mB;AACA,wB;AACA,mB;AACA,6B;AACA,wB;AACA,2B;AACA,E;;AAEA,yC;AACA,4C;AACA,6C;AACA,I;AACA,sD;AACA,kB;AACA,2C;AACA,gD;AACA,gF;AACA,G;AACA,sB;AACA,iC;AACA,wB;AACA,2B;AACA,E;;AAEA,yC;AACA,4C;AACA,kD;AACA,I;AACA,sD;AACA,kB;AACA,gD;AACA,mE;AACA,gC;AACA,G;AACA,gD;AACA,2C;AACA,gE;AACA,2B;AACA,6B;AACA,yB;;;AAGA,kE;AACA,yD;;AAEA,+C;AACA,sC;;AAEA,uC;AACA,wE;;AAEA,kD;AACA,kC;AACA,6B;;AAEA,wC;AACA,wD;AACA,6B;;AAEA,+C;AACA,wB;AACA,K;AACA,uB;AACA,2B;AACA,G;;;AAGA,oB;AACA,+B;AACA,6B;AACA,gD;;AAEA,0C;AACA,wB;AACA,wD;AACA,qD;AACA,G;;;AAGA,mD;AACA,6B;AACA,oB;AACA,iB;AACA,6B;AACA,4B;AACA,2B;AACA,E;;AAEA,yC;AACA,4C;AACA,I;AACA,+C;AACA,kB;AACA,wB;AACA,8B;;AAEA,yB;AACA,oC;AACA,W;AACA,8E;AACA,mB;AACA,G;;AAEA,uB;AACA,2B;AACA,2B;;AAEA,4C;AACA,wC;AACA,6B;AACA,U;AACA,0B;AACA,G;;AAEA,4C;AACA,wC;AACA,6B;AACA,U;AACA,yB;AACA,G;;AAEA,a;AACA,+B;AACA,+B;AACA,0B;AACA,kB;;AAEA,0B;AACA,wB;AACA,iB;AACA,6B;AACA,wB;AACA,2B;AACA,E;;AAEA,8C;AACA,gF;AACA,I;AACA,sD;AACA,kB;;AAEA,wC;AACA,2C;;AAEA,oC;AACA,yB;AACA,G;AACA,kC;AACA,wB;AACA,qB;AACA,oB;AACA,E;;AAEA,+C;AACA,iF;AACA,I;AACA,kD;AACA,gC;AACA,gC;AACA,E;;AAEA,0C;AACA,uD;AACA,gF;AACA,mF;AACA,I;AACA,qE;AACA,kB;AACA,6B;AACA,gC;AACA,gE;AACA,G;AACA,qC;AACA,iD;AACA,oC;AACA,gD;AACA,8C;AACA,mB;AACA,iC;AACA,kC;AACA,wC;AACA,mD;AACA,G;AACA,E;;AAEA,iD;AACA,uD;AACA,gF;AACA,I;AACA,mE;AACA,uC;AACA,sC;AACA,E;;AAEA,8D;AACA,gF;AACA,kC;AACA,kC;AACA,I;AACA,uD;AACA,kB;AACA,2B;AACA,kB;AACA,gC;AACA,8C;AACA,uC;AACA,uB;AACA,mB;AACA,sB;AACA,gB;AACA,E","sourcesContent":["// #ReactiveList\n// Provides a simple reactive list interface\nvar _noopCallback = function() {};\n\nvar _nonReactive = {\n  changed: _noopCallback,\n  depend: _noopCallback\n};\n\n/** @method ReactiveList Keeps a reactive list of key+value items\n  * @constructor\n  * @namespace ReactiveList\n  * @param {object} [options]\n  * @param {function} sort The sort algorithm to use\n  * @param {boolean} [reactive=true] If set false this list is not reactive\n  * Example:\n  * ```js\n  *   var list = new ReactiveList();\n  *   list.insert(1, { text: 'Hello id: 1' });\n  *   list.insert(2, { text: 'Hello id: 2' });\n  *   list.insert(3, { text: 'Hello id: 3' });\n  *   list.update(2, { text: 'Updated 2'});\n  *   list.remove(1);\n  *\n  *   list.forEach(function(value, key) {\n  *     console.log('GOT: ' + value.text);\n  *   }, true); // Set noneReactive = true, default behaviour is reactive\n  *\n  *   // Return from Template:\n  *   Template.hello.list = function() {\n  *     return list.fetch();\n  *   };\n  * ```\n  *\n  * ####Example of a sort algorithm\n  * Sort can be used to define the order of the list\n  * ```js\n  *   var list = new ReactiveList({\n  *     sort: function(a, b) {\n  *       // a and b are type of { key, value }\n  *       // here we sort by the key:\n  *       return a.key < b.key;\n  *     }\n  *   });\n  * ```\n  * ###Object chain\n  * ```\n  *                   first                               last\n  *  undefined -       obj       -       obj       -       obj       - undefined\n  *             (prev value next) (prev value next) (prev value next)\n  * ```\n  */\nReactiveList = function(options) {\n  var self = this;\n  // Object container\n  self.lookup = {};\n  // Length\n  self._length = 0;\n  // First object in list\n  self.first;\n  // Last object in list\n  self.last;\n  // Set sort to options.sort or default to true (asc)\n  self.sort = (options && options.sort || function(a, b) {\n    return a.key < b.key;\n  });\n\n  // Allow user to disable reactivity, default true\n  self.isReactive = (options)? options.reactive !== false : true;\n\n  // If lifo queue\n  if (options === true || options && options.sort === true) {\n    self.sort = function(a, b) { return a.key > b.key; };\n  }\n\n  // Rig the dependencies\n  self._listDeps = (self.isReactive)? new Deps.Dependency() : _nonReactive;\n\n  self._lengthDeps = (self.isReactive)? new Deps.Dependency() : _nonReactive;\n};\n\n/** @method ReactiveList.prototype.length Returns the length of the list\n  * @reactive\n  * @returns {number} Length of the reactive list\n  */\nReactiveList.prototype.length = function() {\n  var self = this;\n  // Make this reactive\n  self._lengthDeps.depend();\n  return self._length;\n};\n\n/** @method ReactiveList.prototype.reset Reset and empty the list\n  * @todo Check for memory leaks, if so we have to iterate over lookup and delete the items\n  */\nReactiveList.prototype.reset = function() {\n  var self = this;\n  // Clear the reference to the first object\n  self.first = undefined;\n  // Clear the reference to the last object\n  self.last = undefined;\n  // Clear the lookup object\n  self.lookup = {};\n  // Set the length to 0\n  self._length = 0;\n  self._lengthDeps.changed();\n  // Invalidate the list\n  self._listDeps.changed();\n};\n\n/** @method ReactiveList.prototype.update\n  * @param {string|number} key Key to update\n  * @param {any} value Update with this value\n  */\nReactiveList.prototype.update = function(key, value) {\n  var self = this;\n  // Make sure the key is found in the list\n  if (typeof self.lookup[key] === 'undefined') {\n    throw new Error('Reactive list cannot update, key \"' + key + '\" not found');\n  }\n  // Set the new value\n  self.lookup[key].value = value;\n  // Invalidate the list\n  self._listDeps.changed();\n};\n\n/** @method ReactiveList.prototype.insert\n  * @param {string|number} key Key to insert\n  * @param {any} value Insert item with this value\n  */\nReactiveList.prototype.insert = function(key, value) {\n  var self = this;\n  if (typeof self.lookup[key] !== 'undefined') {\n    throw new Error('Reactive list could not insert: key \"' + key +\n            '\" allready found');\n  }\n  // Create the new item to insert into the list\n  var newItem = { key: key, value: value };\n  // Init current by pointing it at the first object in the list\n  var current = self.first;\n  // Init the isInserted flag\n  var isInserted = false;\n\n\n  // Iterate through list while not empty and item is not inserted\n  while (typeof current !== 'undefined' && !isInserted) {\n\n    // Sort the list by using the sort function\n    if (self.sort(newItem, current)) {\n\n      // Insert self.lookup[key] before\n      if (typeof current.prev === 'undefined') { self.first = newItem; }\n\n      // Set the references in the inserted object\n      newItem.prev = current.prev;\n      newItem.next = current;\n\n      // Update the two existing objects\n      if (current.prev) { current.prev.next = newItem; }\n      current.prev = newItem;\n\n      // Mark the item as inserted - job's done\n      isInserted = true;\n    }\n    // Goto next object\n    current = current.next;\n  }\n\n\n  if (!isInserted) {\n    // We append it to the list\n    newItem.prev = self.last;\n    if (self.last) { self.last.next = newItem; }\n\n    // Update the last pointing to newItem\n    self.last = newItem;\n    // Update first if we are appending to an empty list\n    if (self._length === 0) { self.first = newItem; }\n  }\n\n\n  // Reference the object for a quick lookup option\n  self.lookup[key] = newItem;\n  // Increase length\n  self._length++;\n  self._lengthDeps.changed();\n  // And invalidate the list\n  self._listDeps.changed();\n};\n\n/** @method ReactiveList.prototype.remove\n  * @param {string|number} key Key to remove\n  */\nReactiveList.prototype.remove = function(key) {\n  var self = this;\n  // Get the item object\n  var item = self.lookup[key];\n\n  // Check that it exists\n  if (typeof item === 'undefined') {\n    return;\n    // throw new Error('ReactiveList cannot remove item, unknow key \"' + key +\n    //        '\"');\n  }\n\n  // Rig the references\n  var prevItem = item.prev;\n  var nextItem = item.next;\n\n  // Update chain prev object next reference\n  if (typeof prevItem !== 'undefined') {\n    prevItem.next = nextItem;\n  } else {\n    self.first = nextItem;\n  }\n\n  // Update chain next object prev reference\n  if (typeof nextItem !== 'undefined') {\n    nextItem.prev = prevItem;\n  } else {\n    self.last = prevItem;\n  }\n\n  // Clean up\n  self.lookup[key].last = null;\n  self.lookup[key].prev = null;\n  self.lookup[key] = null;\n  prevItem = null;\n\n  delete self.lookup[key];\n  // Decrease the length\n  self._length--;\n  self._lengthDeps.changed();\n  // Invalidate the list\n  self._listDeps.changed();\n};\n\n/** @method ReactiveList.prototype.getLastItem\n  * @returns {any} Pops last item from the list - removes the item from the list\n  */\nReactiveList.prototype.getLastItem = function(first) {\n  var self = this;\n\n  // Get the relevant item first or last\n  var item = (first)?self.first: self.last;\n\n  if (typeof item === 'undefined') {\n    return; // Empty list\n  }\n  // Remove the item from the list\n  self.remove(item.key);\n  // Return the value\n  return item.value;\n};\n\n/** @method ReactiveList.prototype.getFirstItem\n  * @returns {any} Pops first item from the list - removes the item from the list\n  */\nReactiveList.prototype.getFirstItem = function() {\n  // This gets the first item...\n  return this.getLastItem(true);\n};\n\n/** @method ReactiveList.prototype.forEach\n  * @param {function} f Callback `funciton(value, key)`\n  * @param {boolean} [noneReactive=false] Set true if want to disable reactivity\n  * @param {boolean} [reverse=false] Set true to reverse iteration `forEachReverse`\n  */\nReactiveList.prototype.forEach = function(f, noneReactive, reverse) {\n  var self = this;\n  // Check if f is a function\n  if (typeof f !== 'function') {\n    throw new Error('ReactiveList forEach requires a function');\n  }\n  // We allow this not to be reactive\n  if (!noneReactive) { self._listDeps.depend(); }\n  // Set current to the first object\n  var current = (reverse)?self.last: self.first;\n  // Iterate over the list while its not empty\n  while (current) {\n    // Call the callback function\n    f(current.value, current.key);\n    // Jump to the next item in the list\n    current = (reverse)?current.prev: current.next;\n  }\n};\n\n/** @method ReactiveList.prototype.forEachReverse\n  * @param {function} f Callback `funciton(value, key)`\n  * @param {boolean} [noneReactive=false] Set true if want to disable reactivity\n  */\nReactiveList.prototype.forEachReverse = function(f, noneReactive) {\n  // Call forEach with the reverse flag\n  this.forEach(f, noneReactive, true);\n};\n\n/** @method ReactiveList.prototype.fetch Returns list as array\n  * @param {boolean} [noneReactive=false] Set true if want to disable reactivity\n  * @reactive This can be disabled\n  * @returns {array} List of items\n  */\nReactiveList.prototype.fetch = function(noneReactive) {\n  var self = this;\n  // Init the result buffer\n  var result = [];\n  // Iterate over the list items\n  self.forEach(function fetchCallback(value) {\n    // Add the item value to the result\n    result.push(value);\n  }, noneReactive);\n  // Return the result\n  return result;\n};\n"]}