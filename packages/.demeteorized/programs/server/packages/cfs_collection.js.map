{"version":3,"sources":["cfs:collection/common.js","cfs:collection/api.common.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA,G;AACA,E;AACA,e;AACA,iD;AACA,0B;AACA,2H;AACA,sD;AACA,uF;AACA,wY;AACA,uB;AACA,G;AACA,yC;AACA,kB;;AAEA,yB;;AAEA,yB;;AAEA,kB;AACA,4B;AACA,0B;AACA,mB;AACA,I;;AAEA,0E;AACA,gE;AACA,8E;AACA,uC;AACA,2D;AACA,4C;AACA,0D;AACA,G;;AAEA,iC;AACA,iD;;AAEA,+B;AACA,mB;;AAEA,oD;AACA,2E;AACA,4E;AACA,gD;AACA,8F;AACA,G;;AAEA,2D;AACA,4B;AACA,kB;AACA,gC;AACA,K;;AAEA,iC;AACA,+D;AACA,gG;AACA,K;;AAEA,qB;AACA,0C;;AAEA,0B;;AAEA,0C;AACA,wD;AACA,qF;AACA,oF;AACA,mC;AACA,qC;AACA,iB;AACA,uJ;AACA,8C;AACA,iE;AACA,qC;AACA,8R;AACA,W;AACA,S;AACA,2C;AACA,S;;AAEA,8D;AACA,qF;AACA,oF;AACA,mC;AACA,qC;AACA,iB;AACA,qK;AACA,8C;AACA,oG;AACA,uE;AACA,qC;AACA,uC;AACA,W;AACA,S;AACA,0C;AACA,S;;AAEA,K;AACA,K;;AAEA,uB;AACA,8B;AACA,+E;AACA,gB;AACA,0C;AACA,mC;AACA,oB;AACA,K;AACA,I;;AAEA,sD;AACA,qD;AACA,mE;;AAEA,4C;AACA,sB;AACA,mC;AACA,I;;AAEA,mB;AACA,0G;AACA,qB;AACA,sC;AACA,G;;AAEA,kG;AACA,+B;;AAEA,qB;AACA,kE;;AAEA,uC;AACA,6B;AACA,gC;AACA,oC;AACA,K;AACA,K;;AAEA,0C;AACA,qB;AACA,0D;AACA,6J;AACA,4C;AACA,qD;AACA,mC;AACA,8O;AACA,S;AACA,O;AACA,O;;AAEA,wD;AACA,mK;AACA,4C;AACA,6G;AACA,O;AACA,O;AACA,+B;AACA,sH;AACA,G;;AAEA,E;;AAEA,mC;AACA,6C;;;;;;;;;;;;;;;;;;AClKA,mG;AACA,U;AACA,yG;AACA,mE;AACA,iD;AACA,gD;AACA,G;AACA,8D;AACA,kB;;AAEA,qC;AACA,0C;AACA,G;;AAEA,S;AACA,8D;AACA,iE;AACA,oD;AACA,6D;AACA,wD;AACA,kC;;AAEA,6C;AACA,0B;AACA,8D;AACA,K;;AAEA,qE;AACA,gE;AACA,qE;AACA,+B;AACA,+E;AACA,K;AACA,G;;AAEA,iF;AACA,oC;AACA,sF;AACA,2F;AACA,gD;AACA,oC;AACA,6G;AACA,K;;AAEA,0B;AACA,uC;;AAEA,8B;AACA,0E;AACA,wB;AACA,mB;AACA,8F;AACA,kB;AACA,4B;AACA,+B;AACA,W;AACA,gB;AACA,oG;AACA,2B;AACA,8D;AACA,gC;AACA,S;AACA,8C;AACA,S;AACA,Y;AACA,2E;AACA,0D;AACA,4B;AACA,K;AACA,mB;AACA,G;;AAEA,0B;AACA,mC;AACA,mC;AACA,U;AACA,0G;AACA,wD;AACA,uC;AACA,mB;AACA,sE;AACA,oB;AACA,0B;AACA,gB;AACA,kC;AACA,S;AACA,S;AACA,Y;AACA,yF;AACA,iE;AACA,kC;AACA,8B;AACA,K;AACA,mB;AACA,G;AACA,E;;AAEA,iE;AACA,U;AACA,mC;AACA,2B;AACA,4B;AACA,+B;AACA,gD;AACA,G;AACA,kF;AACA,kB;AACA,oC;AACA,uD;AACA,uD;AACA,0D;AACA,Y;AACA,wD;AACA,wI;AACA,K;AACA,G;;AAEA,kE;AACA,E;;AAEA,8E;AACA,U;AACA,mC;AACA,+B;AACA,gD;AACA,G;AACA,+D;AACA,kB;AACA,oC;;AAEA,uD;AACA,uD;AACA,uC;AACA,Y;AACA,4D;AACA,wI;AACA,K;AACA,G;;AAEA,2D;AACA,oD;AACA,+C;AACA,E;;AAEA,2C;AACA,U;AACA,kE;AACA,iD;AACA,W;AACA,M;AACA,uC;AACA,uB;AACA,uD;AACA,I;AACA,G;AACA,mC;AACA,sD;AACA,kB;AACA,yD;AACA,E;;AAEA,wC;AACA,U;AACA,kE;AACA,8C;AACA,W;AACA,M;AACA,uC;AACA,4B;AACA,+D;AACA,I;AACA,G;AACA,mD;AACA,kB;AACA,sD;AACA,E;;AAEA,yC;AACA,U;AACA,0B;AACA,iG;AACA,mC;AACA,mC;AACA,0I;AACA,kL;AACA,+C;AACA,W;AACA,M;AACA,uC;AACA,4B;AACA,2B;AACA,gD;AACA,kE;AACA,gD;AACA,sD;AACA,I;AACA,I;AACA,G;AACA,mD;AACA,kB;;AAEA,6C;AACA,yB;AACA,kD;AACA,wE;AACA,K;AACA,2D;AACA,4B;AACA,G;;AAEA,oD;AACA,E;;AAEA,wC;AACA,U;AACA,0B;AACA,iG;AACA,mC;AACA,mC;AACA,yI;AACA,kL;AACA,8C;AACA,W;AACA,M;AACA,uC;AACA,4B;AACA,0B;AACA,gD;AACA,kE;AACA,gD;AACA,sD;AACA,I;AACA,I;AACA,G;AACA,kD;AACA,kB;;AAEA,6C;AACA,yB;AACA,kD;AACA,uE;AACA,K;AACA,0D;AACA,4B;AACA,G;;AAEA,mD;AACA,E;;AAEA,gB;;AAEA,G;AACA,gE;AACA,sF;AACA,wC;AACA,4D;AACA,G;AACA,wE;AACA,c;AACA,E","file":"/packages/cfs_collection.js","sourcesContent":["/**\n *\n * @constructor\n * @param {string} name A name for the collection\n * @param {Object} options\n * @param {FS.StorageAdapter[]} options.stores An array of stores in which files should be saved. At least one is required.\n * @param {Object} [options.filter] Filter definitions\n * @param {Number} [options.chunkSize=2MB] Override the chunk size in bytes for uploads\n * @param {Function} [options.uploader] A function to pass FS.File instances after inserting, which will begin uploading them. By default, `FS.HTTP.uploadQueue.uploadFile` is used if the `cfs-upload-http` package is present, or `FS.DDP.uploadQueue.uploadFile` is used if the `cfs-upload-ddp` package is present. You can override with your own, or set to `null` to prevent automatic uploading.\n * @returns {undefined}\n */\nFS.Collection = function(name, options) {\n  var self = this;\n\n  self.storesLookup = {};\n\n  self.primaryStore = {};\n\n  self.options = {\n    filter: null, //optional\n    stores: [], //required\n    chunkSize: null\n  };\n\n  // Define a default uploader based on which upload packages are present,\n  // preferring HTTP. You may override with your own function or\n  // set to null to skip automatic uploading of data after file insert/update.\n  if (FS.HTTP && FS.HTTP.uploadQueue) {\n    self.options.uploader = FS.HTTP.uploadQueue.uploadFile;\n  } else if (FS.DDP && FS.DDP.uploadQueue) {\n    self.options.uploader = FS.DDP.uploadQueue.uploadFile;\n  }\n\n  // Extend and overwrite options\n  FS.Utility.extend(self.options, options || {});\n\n  // Set the FS.Collection name\n  self.name = name;\n\n  // Make sure at least one store has been supplied.\n  // Usually the stores aren't used on the client, but we need them defined\n  // so that we can access their names and use the first one as the default.\n  if (FS.Utility.isEmpty(self.options.stores)) {\n    throw new Error(\"You must specify at least one store. Please consult the documentation.\");\n  }\n\n  FS.Utility.each(self.options.stores, function(store, i) {\n    // Set the primary store\n    if (i === 0) {\n      self.primaryStore = store;\n    }\n\n    // Check for duplicate naming\n    if (typeof self.storesLookup[store.name] !== 'undefined') {\n      throw new Error('FS.Collection store names must be uniq, duplicate found: ' + store.name);\n    }\n\n    // Set the lookup\n    self.storesLookup[store.name] = store;\n\n    if (Meteor.isServer) {\n\n      // Emit events based on store events\n      store.on('stored', function (storeName, fileObj) {\n        // This is weird, but currently there is a bug where each store will emit the\n        // events for all other stores, too, so we need to make sure that this event\n        // is truly for this store.\n        if (storeName !== store.name)\n          return;\n        // When a file is successfully stored into the store, we emit a \"stored\" event on the FS.Collection only if the file belongs to this collection\n        if (fileObj.collectionName === name) {\n          var emitted = self.emit('stored', fileObj, store.name);\n          if (FS.debug && !emitted) {\n            console.log(fileObj.name({store: store.name}) + ' was successfully saved to the ' + store.name + ' store. You are seeing this informational message because you enabled debugging and you have not defined any listeners for the \"stored\" event on the ' + name + ' collection.');\n          }\n        }\n        fileObj.emit('stored', store.name);\n      });\n\n      store.on('error', function (storeName, error, fileObj) {\n        // This is weird, but currently there is a bug where each store will emit the\n        // events for all other stores, too, so we need to make sure that this event\n        // is truly for this store.\n        if (storeName !== store.name)\n          return;\n        // When a file has an error while being stored into the temp store, we emit an \"error\" event on the FS.Collection only if the file belongs to this collection\n        if (fileObj.collectionName === name) {\n          error = new Error('Error storing file to the ' + store.name + ' store: ' + error.message);\n          var emitted = self.emit('error', error, fileObj, store.name);\n          if (FS.debug && !emitted) {\n            console.log(error.message);\n          }\n        }\n        fileObj.emit('error', store.name);\n      });\n\n    }\n  });\n\n  var _filesOptions = {\n    transform: function(doc) {\n      // This should keep the filerecord in the file object updated in reactive\n      // context\n      var result = new FS.File(doc, true);\n      result.collectionName = name;\n      return result;\n    }\n  };\n\n  // Create the 'cfs.' ++ \".filerecord\" and use fsFile\n  var collectionName = 'cfs.' + name + '.filerecord';\n  self.files = new Mongo.Collection(collectionName, _filesOptions);\n\n  // For storing custom allow/deny functions\n  self._validators = {\n    download: {allow: [], deny: []}\n  };\n\n  // Set up filters\n  // XXX Should we deprecate the filter option now that this is done with a separate pkg, or just keep it?\n  if (self.filters) {\n    self.filters(self.options.filter);\n  }\n\n  // Save the collection reference (we want it without the 'cfs.' prefix and '.filerecord' suffix)\n  FS._collections[name] = this;\n\n  // Set up observers\n  Meteor.isServer && FS.FileWorker && FS.FileWorker.observe(this);\n\n  // Emit \"removed\" event on collection\n  self.files.find().observe({\n    removed: function(fileObj) {\n      self.emit('removed', fileObj);\n    }\n  });\n\n  // Emit events based on TempStore events\n  if (FS.TempStore) {\n    FS.TempStore.on('stored', function (fileObj, result) {\n      // When a file is successfully stored into the temp store, we emit an \"uploaded\" event on the FS.Collection only if the file belongs to this collection\n      if (fileObj.collectionName === name) {\n        var emitted = self.emit('uploaded', fileObj);\n        if (FS.debug && !emitted) {\n          console.log(fileObj.name() + ' was successfully uploaded. You are seeing this informational message because you enabled debugging and you have not defined any listeners for the \"uploaded\" event on the ' + name + ' collection.');\n        }\n      }\n    });\n\n    FS.TempStore.on('error', function (error, fileObj) {\n      // When a file has an error while being stored into the temp store, we emit an \"error\" event on the FS.Collection only if the file belongs to this collection\n      if (fileObj.collectionName === name) {\n        self.emit('error', new Error('Error storing uploaded file to TempStore: ' + error.message), fileObj);\n      }\n    });\n  } else if (Meteor.isServer) {\n    throw new Error(\"FS.Collection constructor: FS.TempStore must be defined before constructing any FS.Collections.\")\n  }\n\n};\n\n// An FS.Collection can emit events\nFS.Collection.prototype = new EventEmitter();","/** @method FS.Collection.prototype.insert Insert `File` or `FS.File` or remote URL into collection\n * @public\n * @param {File|Blob|Buffer|ArrayBuffer|Uint8Array|String} fileRef File, FS.File, or other data to insert\n * @param {function} [callback] Callback `function(error, fileObj)`\n * @returns {FS.File|undefined} The `file object`\n * [Meteor docs](http://docs.meteor.com/#insert)\n */\nFS.Collection.prototype.insert = function(fileRef, callback) {\n  var self = this;\n\n  if (Meteor.isClient && !callback) {\n    callback = FS.Utility.defaultCallback;\n  }\n\n  // XXX:\n  // We should out factor beginStorage to FS.File.beginStorage\n  // the client side storage adapters should be the one providing\n  // the upload either via http/ddp or direct upload\n  // Could be cool to have a streaming api on the client side\n  // having a createReadStream etc. on the client too...\n  function beginStorage(fileObj) {\n\n    // If on client, begin uploading the data\n    if (Meteor.isClient) {\n      self.options.uploader && self.options.uploader(fileObj);\n    }\n\n    // If on the server, save the binary to a single chunk temp file,\n    // so that it is available when FileWorker calls saveCopies.\n    // This will also trigger file handling from collection observes.\n    else if (Meteor.isServer) {\n      fileObj.createReadStream().pipe(FS.TempStore.createWriteStream(fileObj));\n    }\n  }\n\n  // XXX: would be great if this function could be simplyfied - if even possible?\n  function checkAndInsert(fileObj) {\n    // Check filters. This is called in deny functions, too, but we call here to catch\n    // server inserts and to catch client inserts early, allowing us to call `onInvalid` on\n    // the client and save a trip to the server.\n    if (!self.allowsFile(fileObj)) {\n      return FS.Utility.handleError(callback, 'FS.Collection insert: file does not pass collection filters');\n    }\n\n    // Set collection name\n    fileObj.collectionName = self.name;\n\n    // Insert the file into db\n    // We call cloneFileRecord as an easy way of extracting the properties\n    // that need saving.\n    if (callback) {\n      fileObj._id = self.files.insert(FS.Utility.cloneFileRecord(fileObj), function(err, id) {\n        if (err) {\n          if (fileObj._id) {\n            delete fileObj._id;\n          }\n        } else {\n          // Set _id, just to be safe, since this could be before or after the insert method returns\n          fileObj._id = id;\n          // Pass to uploader or stream data to the temp store\n          beginStorage(fileObj);\n        }\n        callback(err, err ? void 0 : fileObj);\n      });\n    } else {\n      fileObj._id = self.files.insert(FS.Utility.cloneFileRecord(fileObj));\n      // Pass to uploader or stream data to the temp store\n      beginStorage(fileObj);\n    }\n    return fileObj;\n  }\n\n  // Parse, adjust fileRef\n  if (fileRef instanceof FS.File) {\n    return checkAndInsert(fileRef);\n  } else {\n    // For convenience, allow File, Blob, Buffer, data URI, filepath, URL, etc. to be passed as first arg,\n    // and we will attach that to a new fileobj for them\n    var fileObj = new FS.File(fileRef);\n    if (callback) {\n      fileObj.attachData(fileRef, function attachDataCallback(error) {\n        if (error) {\n          callback(error);\n        } else {\n          checkAndInsert(fileObj);\n        }\n      });\n    } else {\n      // We ensure there's a callback on the client, so if there isn't one at this point,\n      // we must be on the server expecting synchronous behavior.\n      fileObj.attachData(fileRef);\n      checkAndInsert(fileObj);\n    }\n    return fileObj;\n  }\n};\n\n/** @method FS.Collection.prototype.update Update the file record\n * @public\n * @param {FS.File|object} selector\n * @param {object} modifier\n * @param {object} [options]\n * @param {function} [callback]\n * [Meteor docs](http://docs.meteor.com/#update)\n */\nFS.Collection.prototype.update = function(selector, modifier, options, callback) {\n  var self = this;\n  if (selector instanceof FS.File) {\n    // Make sure the file belongs to this FS.Collection\n    if (selector.collectionName === self.files._name) {\n      return selector.update(modifier, options, callback);\n    } else {\n      // Tried to save a file in the wrong FS.Collection\n      throw new Error('FS.Collection cannot update file belongs to: \"' + selector.collectionName + '\" not: \"' + self.files._name + '\"');\n    }\n  }\n\n  return self.files.update(selector, modifier, options, callback);\n};\n\n/** @method FS.Collection.prototype.remove Remove the file from the collection\n * @public\n * @param {FS.File|object} selector\n * @param {Function} [callback]\n * [Meteor docs](http://docs.meteor.com/#remove)\n */\nFS.Collection.prototype.remove = function(selector, callback) {\n  var self = this;\n  if (selector instanceof FS.File) {\n\n    // Make sure the file belongs to this FS.Collection\n    if (selector.collectionName === self.files._name) {\n      return selector.remove(callback);\n    } else {\n      // Tried to remove a file from the wrong FS.Collection\n      throw new Error('FS.Collection cannot remove file belongs to: \"' + selector.collectionName + '\" not: \"' + self.files._name + '\"');\n    }\n  }\n\n  //doesn't work correctly on the client without a callback\n  callback = callback || FS.Utility.defaultCallback;\n  return self.files.remove(selector, callback);\n};\n\n/** @method FS.Collection.prototype.findOne\n * @public\n * @param {[selector](http://docs.meteor.com/#selectors)} selector\n * [Meteor docs](http://docs.meteor.com/#findone)\n * Example:\n ```js\n var images = new FS.Collection( ... );\n // Get the file object\n var fo = images.findOne({ _id: 'NpnskCt6ippN6CgD8' });\n ```\n */\n// Call findOne on files collection\nFS.Collection.prototype.findOne = function(selector) {\n  var self = this;\n  return self.files.findOne.apply(self.files, arguments);\n};\n\n/** @method FS.Collection.prototype.find\n * @public\n * @param {[selector](http://docs.meteor.com/#selectors)} selector\n * [Meteor docs](http://docs.meteor.com/#find)\n * Example:\n ```js\n var images = new FS.Collection( ... );\n // Get the all file objects\n var files = images.find({ _id: 'NpnskCt6ippN6CgD8' }).fetch();\n ```\n */\nFS.Collection.prototype.find = function(selector) {\n  var self = this;\n  return self.files.find.apply(self.files, arguments);\n};\n\n/** @method FS.Collection.prototype.allow\n * @public\n * @param {object} options\n * @param {function} options.download Function that checks if the file contents may be downloaded\n * @param {function} options.insert\n * @param {function} options.update\n * @param {function} options.remove Functions that look at a proposed modification to the database and return true if it should be allowed\n * @param {[string]} [options.fetch] Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your update and remove functions\n * [Meteor docs](http://docs.meteor.com/#allow)\n * Example:\n ```js\n var images = new FS.Collection( ... );\n // Get the all file objects\n var files = images.allow({\n insert: function(userId, doc) { return true; },\n update: function(userId, doc, fields, modifier) { return true; },\n remove: function(userId, doc) { return true; },\n download: function(userId, fileObj) { return true; },\n });\n ```\n */\nFS.Collection.prototype.allow = function(options) {\n  var self = this;\n\n  // Pull out the custom \"download\" functions\n  if (options.download) {\n    if (!(options.download instanceof Function)) {\n      throw new Error(\"allow: Value for `download` must be a function\");\n    }\n    self._validators.download.allow.push(options.download);\n    delete options.download;\n  }\n\n  return self.files.allow.call(self.files, options);\n};\n\n/** @method FS.Collection.prototype.deny\n * @public\n * @param {object} options\n * @param {function} options.download Function that checks if the file contents may be downloaded\n * @param {function} options.insert\n * @param {function} options.update\n * @param {function} options.remove Functions that look at a proposed modification to the database and return true if it should be denyed\n * @param {[string]} [options.fetch] Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your update and remove functions\n * [Meteor docs](http://docs.meteor.com/#deny)\n * Example:\n ```js\n var images = new FS.Collection( ... );\n // Get the all file objects\n var files = images.deny({\n insert: function(userId, doc) { return true; },\n update: function(userId, doc, fields, modifier) { return true; },\n remove: function(userId, doc) { return true; },\n download: function(userId, fileObj) { return true; },\n });\n ```\n */\nFS.Collection.prototype.deny = function(options) {\n  var self = this;\n\n  // Pull out the custom \"download\" functions\n  if (options.download) {\n    if (!(options.download instanceof Function)) {\n      throw new Error(\"deny: Value for `download` must be a function\");\n    }\n    self._validators.download.deny.push(options.download);\n    delete options.download;\n  }\n\n  return self.files.deny.call(self.files, options);\n};\n\n// TODO: Upsert?\n\n/**\n * We provide a default implementation that doesn't do anything.\n * Can be changed by user or packages, such as the default cfs-collection-filters pkg.\n * @param  {FS.File} fileObj File object\n * @return {Boolean} Should we allow insertion of this file?\n */\nFS.Collection.prototype.allowsFile = function fsColAllowsFile(fileObj) {\n  return true;\n};\n"]}