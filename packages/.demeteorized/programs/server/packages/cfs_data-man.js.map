{"version":3,"sources":["cfs:data-man/server/data-man-api.js","cfs:data-man/server/data-man-buffer.js","cfs:data-man/server/data-man-datauri.js","cfs:data-man/server/data-man-filepath.js","cfs:data-man/server/data-man-url.js","cfs:data-man/server/data-man-readstream.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;AAAA,iC;;AAEA,2B;AACA,8C;;AAEA,G;AACA,kB;AACA,U;AACA,e;AACA,2F;AACA,6I;AACA,0G;AACA,G;AACA,iD;AACA,0B;;AAEA,c;AACA,oE;AACA,G;;AAEA,iF;AACA,qE;AACA,I;AACA,8E;AACA,qE;AACA,gE;AACA,gB;AACA,2F;AACA,K;AACA,iD;AACA,iF;AACA,wC;AACA,0E;AACA,K;AACA,gB;AACA,iG;AACA,K;AACA,8C;AACA,mD;AACA,oC;AACA,wC;AACA,0E;AACA,K;AACA,gB;AACA,+F;AACA,K;AACA,8B;AACA,mD;AACA,2E;AACA,gB;AACA,oG;AACA,K;AACA,qD;AACA,wC;AACA,uC;AACA,8C;AACA,+E;AACA,kB;AACA,0F;AACA,O;AACA,yD;AACA,Y;AACA,+B;AACA,qD;AACA,K;AACA,U;AACA,iF;AACA,G;AACA,E;;AAEA,G;AACA,sC;AACA,U;AACA,qD;AACA,8B;AACA,E;AACA,+E;AACA,G;AACA,mE;AACA,kB;AACA,mH;AACA,E;;AAEA,sD;AACA,mD;AACA,8D;AACA,e;AACA,6C;AACA,mE;AACA,oB;AACA,6C;AACA,+B;AACA,C;;AAEA,G;AACA,uC;AACA,U;AACA,2B;AACA,6B;AACA,uB;AACA,E;AACA,yD;AACA,G;AACA,+E;AACA,2C;AACA,sH;AACA,E;;AAEA,G;AACA,uC;AACA,U;AACA,sD;AACA,E;AACA,wC;AACA,G;AACA,qE;AACA,kB;AACA,qH;AACA,E;;AAEA,G;AACA,6C;AACA,U;AACA,E;AACA,sC;AACA,G;AACA,yE;AACA,wC;AACA,E;;AAEA,G;AACA,iC;AACA,U;AACA,mD;AACA,E;AACA,yD;AACA,G;AACA,yD;AACA,kB;AACA,yG;AACA,E;;AAEA,G;AACA,iC;AACA,U;AACA,E;AACA,gC;AACA,G;AACA,iD;AACA,4B;AACA,E;;AAEA,E;AACA,4D;AACA,G;AACA,kC;AACA,yC;AACA,wB;AACA,0B;AACA,oE;AACA,C;AACA,8B;AACA,kB;AACA,sG;AACA,6C;AACA,kC;AACA,6B;AACA,iG;AACA,oC;AACA,wB;AACA,0B;AACA,sE;AACA,iD;AACA,gB;AACA,I;AACA,C;;;;;;;;;;;;;;;;;;;AC/KA,6D;;AAEA,G;AACA,yB;AACA,U;AACA,e;AACA,yB;AACA,qD;AACA,G;AACA,uD;AACA,kB;AACA,uB;AACA,oB;AACA,E;;AAEA,G;AACA,6C;AACA,W;AACA,mD;AACA,8B;AACA,E;AACA,uD;AACA,G;AACA,gF;AACA,8B;AACA,E;;AAEA,G;AACA,8C;AACA,W;AACA,oD;AACA,E;AACA,uE;AACA,G;AACA,kF;AACA,kB;AACA,oB;AACA,yE;AACA,U;AACA,qF;AACA,4B;AACA,G;AACA,E;;AAEA,G;AACA,oD;AACA,W;AACA,E;AACA,sC;AACA,G;AACA,sF;AACA,6C;AACA,E;;AAEA,G;AACA,wC;AACA,iD;AACA,W;AACA,E;AACA,oE;AACA,G;AACA,sE;AACA,kB;;AAEA,uC;AACA,+B;AACA,W;AACA,G;;AAEA,kC;AACA,6B;AACA,E;;AAEA,G;AACA,wC;AACA,W;AACA,E;AACA,gC;AACA,G;AACA,8D;AACA,oB;AACA,E;;;;;;;;;;;;;;;;;;;ACjFA,G;AACA,0B;AACA,U;AACA,e;AACA,0B;AACA,G;AACA,oD;AACA,kB;AACA,wD;AACA,+C;AACA,+C;AACA,E;;AAEA,qD;;;;;;;;;;;;;;;;;;;ACbA,+B;AACA,2B;;AAEA,G;AACA,2B;AACA,U;AACA,e;AACA,2B;AACA,4F;AACA,G;AACA,6D;AACA,kB;AACA,2B;AACA,6C;AACA,E;;AAEA,G;AACA,+C;AACA,W;AACA,mD;AACA,8B;AACA,E;AACA,uD;AACA,G;AACA,oF;AACA,kB;;AAEA,uB;AACA,2E;AACA,0B;AACA,oB;AACA,kB;AACA,M;AACA,E;;AAEA,G;AACA,gD;AACA,W;AACA,oD;AACA,E;AACA,yD;AACA,G;AACA,sF;AACA,kB;;AAEA,2C;AACA,gB;AACA,sB;AACA,Y;AACA,wB;AACA,6E;AACA,c;AACA,oF;AACA,sB;AACA,gC;AACA,O;AACA,K;AACA,K;AACA,E;;AAEA,G;AACA,sD;AACA,W;AACA,E;AACA,sC;AACA,G;AACA,0F;AACA,2B;AACA,4C;AACA,E;;AAEA,G;AACA,0C;AACA,iD;AACA,W;AACA,E;AACA,sD;AACA,G;AACA,0E;AACA,kB;;AAEA,uC;AACA,+B;AACA,W;AACA,G;;AAEA,0C;AACA,yE;AACA,kD;AACA,8B;AACA,iC;AACA,Y;AACA,sB;AACA,K;AACA,uB;AACA,oB;AACA,M;AACA,E;;AAEA,G;AACA,0C;AACA,W;AACA,E;AACA,gC;AACA,G;AACA,kE;AACA,oB;AACA,E;;;;;;;;;;;;;;;;;;;AC3GA,qC;;AAEA,G;AACA,sB;AACA,U;AACA,e;AACA,sB;AACA,qD;AACA,G;AACA,uD;AACA,kB;AACA,0B;;AAEA,iB;AACA,oB;;AAEA,gE;AACA,iE;AACA,oE;AACA,iE;AACA,qB;AACA,sC;AACA,+E;AACA,4C;AACA,gD;AACA,6D;AACA,wB;AACA,G;;AAEA,yB;AACA,E;;AAEA,G;AACA,0C;AACA,W;AACA,mD;AACA,8B;AACA,E;AACA,kE;AACA,G;AACA,0E;AACA,kB;;AAEA,oB;AACA,kB;AACA,kB;AACA,mB;AACA,c;AACA,qE;AACA,c;AACA,oB;AACA,Y;AACA,+C;AACA,2B;AACA,K;AACA,oB;AACA,kB;AACA,M;AACA,E;;AAEA,G;AACA,2C;AACA,W;AACA,oD;AACA,E;AACA,oE;AACA,G;AACA,4E;AACA,kB;;AAEA,2C;AACA,gB;AACA,sB;AACA,Y;AACA,wB;AACA,6E;AACA,c;AACA,oF;AACA,gC;AACA,O;AACA,K;AACA,K;AACA,E;;AAEA,G;AACA,iD;AACA,W;AACA,E;AACA,sC;AACA,G;AACA,gF;AACA,kB;AACA,oB;AACA,2B;AACA,kB;AACA,iB;AACA,oB;AACA,E;;AAEA,G;AACA,qC;AACA,iD;AACA,W;AACA,E;AACA,oD;AACA,G;AACA,gE;AACA,kB;;AAEA,uC;AACA,+B;AACA,W;AACA,G;;AAEA,2C;AACA,gB;AACA,sB;AACA,Y;AACA,iC;AACA,iC;AACA,K;AACA,K;AACA,E;;AAEA,G;AACA,qC;AACA,W;AACA,E;AACA,gC;AACA,G;AACA,wD;AACA,oB;AACA,E;;;;;;;;;;;;;;;;;;;ACpIA,oB;;AAEA,oD;;AAEA,G;AACA,6B;AACA,U;AACA,e;AACA,6B;AACA,qD;AACA,G;AACA,2D;AACA,kB;;AAEA,+C;AACA,6B;;AAEA,uD;AACA,kB;;AAEA,sC;AACA,mB;;AAEA,yB;AACA,oB;AACA,E;;AAEA,G;AACA,iD;AACA,W;AACA,mD;AACA,uB;AACA,E;AACA,uD;AACA,G;AACA,4F;AACA,0C;AACA,E;;AAEA,G;AACA,kD;AACA,W;AACA,oD;AACA,E;AACA,uE;AACA,G;AACA,8F;AACA,0C;AACA,E;;AAEA,G;AACA,wD;AACA,W;AACA,E;AACA,sC;AACA,G;AACA,8F;AACA,qB;AACA,E;;AAEA,G;AACA,4C;AACA,iD;AACA,W;AACA,E;AACA,oE;AACA,G;AACA,8E;AACA,kD;AACA,E;;AAEA,G;AACA,4C;AACA,W;AACA,E;AACA,gC;AACA,G;AACA,sE;AACA,oB;AACA,E","file":"/packages/cfs:data-man.js","sourcesContent":["/* global DataMan:true, Buffer */\n\nvar fs = Npm.require(\"fs\");\nvar Readable = Npm.require('stream').Readable;\n\n/**\n * @method DataMan\n * @public\n * @constructor\n * @param {Buffer|ArrayBuffer|Uint8Array|String} data The data that you want to manipulate.\n * @param {String} [type] The data content (MIME) type, if known. Required if the first argument is a Buffer, ArrayBuffer, Uint8Array, or URL\n * @param {Object} [options] Currently used only to pass options for the GET request when `data` is a URL.\n */\nDataMan = function DataMan(data, type, options) {\n  var self = this, buffer;\n\n  if (!data) {\n    throw new Error(\"DataMan constructor requires a data argument\");\n  }\n\n  // The end result of all this is that we will have this.source set to a correct\n  // data type handler. We are simply detecting what the data arg is.\n  //\n  // Unless we already have in-memory data, we don't load anything into memory\n  // and instead rely on obtaining a read stream when the time comes.\n  if (typeof Buffer !== \"undefined\" && data instanceof Buffer) {\n    if (!type) {\n      throw new Error(\"DataMan constructor requires a type argument when passed a Buffer\");\n    }\n    self.source = new DataMan.Buffer(data, type);\n  } else if (typeof ArrayBuffer !== \"undefined\" && data instanceof ArrayBuffer) {\n    if (typeof Buffer === \"undefined\") {\n      throw new Error(\"Buffer support required to handle an ArrayBuffer\");\n    }\n    if (!type) {\n      throw new Error(\"DataMan constructor requires a type argument when passed an ArrayBuffer\");\n    }\n    buffer = new Buffer(new Uint8Array(data));\n    self.source = new DataMan.Buffer(buffer, type);\n  } else if (EJSON.isBinary(data)) {\n    if (typeof Buffer === \"undefined\") {\n      throw new Error(\"Buffer support required to handle an ArrayBuffer\");\n    }\n    if (!type) {\n      throw new Error(\"DataMan constructor requires a type argument when passed a Uint8Array\");\n    }\n    buffer = new Buffer(data);\n    self.source = new DataMan.Buffer(buffer, type);\n  } else if (typeof Readable !== \"undefined\" && data instanceof Readable) {\n    if (!type) {\n      throw new Error(\"DataMan constructor requires a type argument when passed a stream.Readable\");\n    }\n    self.source = new DataMan.ReadStream(data, type);\n  } else if (typeof data === \"string\") {\n    if (data.slice(0, 5) === \"data:\") {\n      self.source = new DataMan.DataURI(data);\n    } else if (data.slice(0, 5) === \"http:\" || data.slice(0, 6) === \"https:\") {\n      if (!type) {\n        throw new Error(\"DataMan constructor requires a type argument when passed a URL\");\n      }\n      self.source = new DataMan.URL(data, type, options);\n    } else {\n      // assume it's a filepath\n      self.source = new DataMan.FilePath(data, type);\n    }\n  } else {\n    throw new Error(\"DataMan constructor received data that it doesn't support\");\n  }\n};\n\n/**\n * @method DataMan.prototype.getBuffer\n * @public\n * @param {function} [callback] callback(err, buffer)\n * @returns {Buffer|undefined}\n *\n * Returns a Buffer representing this data, or passes the Buffer to a callback.\n */\nDataMan.prototype.getBuffer = function dataManGetBuffer(callback) {\n  var self = this;\n  return callback ? self.source.getBuffer(callback) : Meteor.wrapAsync(bind(self.source.getBuffer, self.source))();\n};\n\nfunction _saveToFile(readStream, filePath, callback) {\n  var writeStream = fs.createWriteStream(filePath);\n  writeStream.on('close', Meteor.bindEnvironment(function () {\n    callback();\n  }, function (error) { callback(error); }));\n  writeStream.on('error', Meteor.bindEnvironment(function (error) {\n    callback(error);\n  }, function (error) { callback(error); }));\n  readStream.pipe(writeStream);\n}\n\n/**\n * @method DataMan.prototype.saveToFile\n * @public\n * @param {String} filePath\n * @param {Function} callback\n * @returns {undefined}\n *\n * Saves this data to a filepath on the local filesystem.\n */\nDataMan.prototype.saveToFile = function dataManSaveToFile(filePath, callback) {\n  var readStream = this.createReadStream();\n  return callback ? _saveToFile(readStream, filePath, callback) : Meteor.wrapAsync(_saveToFile)(readStream, filePath);\n};\n\n/**\n * @method DataMan.prototype.getDataUri\n * @public\n * @param {function} [callback] callback(err, dataUri)\n *\n * If no callback, returns the data URI.\n */\nDataMan.prototype.getDataUri = function dataManGetDataUri(callback) {\n  var self = this;\n  return callback ? self.source.getDataUri(callback) : Meteor.wrapAsync(bind(self.source.getDataUri, self.source))();\n};\n\n/**\n * @method DataMan.prototype.createReadStream\n * @public\n *\n * Returns a read stream for the data.\n */\nDataMan.prototype.createReadStream = function dataManCreateReadStream() {\n  return this.source.createReadStream();\n};\n\n/**\n * @method DataMan.prototype.size\n * @public\n * @param {function} [callback] callback(err, size)\n *\n * If no callback, returns the size in bytes of the data.\n */\nDataMan.prototype.size = function dataManSize(callback) {\n  var self = this;\n  return callback ? self.source.size(callback) : Meteor.wrapAsync(bind(self.source.size, self.source))();\n};\n\n/**\n * @method DataMan.prototype.type\n * @public\n *\n * Returns the type of the data.\n */\nDataMan.prototype.type = function dataManType() {\n  return this.source.type();\n};\n\n/*\n * \"bind\" shim; from underscorejs, but we avoid a dependency\n */\nvar slice = Array.prototype.slice;\nvar nativeBind = Function.prototype.bind;\nvar ctor = function(){};\nfunction isFunction(obj) {\n  return Object.prototype.toString.call(obj) == '[object Function]';\n}\nfunction bind(func, context) {\n  var args, bound;\n  if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n  if (!isFunction(func)) throw new TypeError;\n  args = slice.call(arguments, 2);\n  return bound = function() {\n    if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));\n    ctor.prototype = func.prototype;\n    var self = new ctor;\n    ctor.prototype = null;\n    var result = func.apply(self, args.concat(slice.call(arguments)));\n    if (Object(result) === result) return result;\n    return self;\n  };\n}\n","var bufferStreamReader = Npm.require('buffer-stream-reader');\n\n/**\n * @method DataMan.Buffer\n * @public\n * @constructor\n * @param {Buffer} buffer\n * @param {String} type The data content (MIME) type.\n */\nDataMan.Buffer = function DataManBuffer(buffer, type) {\n  var self = this;\n  self.buffer = buffer;\n  self._type = type;\n};\n\n/**\n * @method DataMan.Buffer.prototype.getBuffer\n * @private\n * @param {function} callback callback(err, buffer)\n * @returns {Buffer|undefined}\n *\n * Passes a Buffer representing the data to a callback.\n */\nDataMan.Buffer.prototype.getBuffer = function dataManBufferGetBuffer(callback) {\n  callback(null, this.buffer);\n};\n\n/**\n * @method DataMan.Buffer.prototype.getDataUri\n * @private\n * @param {function} callback callback(err, dataUri)\n *\n * Passes a data URI representing the data in the buffer to a callback.\n */\nDataMan.Buffer.prototype.getDataUri = function dataManBufferGetDataUri(callback) {\n  var self = this;\n  if (!self._type) {\n    callback(new Error(\"DataMan.getDataUri couldn't get a contentType\"));\n  } else {\n    var dataUri = \"data:\" + self._type + \";base64,\" + self.buffer.toString(\"base64\");\n    callback(null, dataUri);\n  }\n};\n\n/**\n * @method DataMan.Buffer.prototype.createReadStream\n * @private\n *\n * Returns a read stream for the data.\n */\nDataMan.Buffer.prototype.createReadStream = function dataManBufferCreateReadStream() {\n  return new bufferStreamReader(this.buffer);\n};\n\n/**\n * @method DataMan.Buffer.prototype.size\n * @param {function} callback callback(err, size)\n * @private\n *\n * Passes the size in bytes of the data in the buffer to a callback.\n */\nDataMan.Buffer.prototype.size = function dataManBufferSize(callback) {\n  var self = this;\n\n  if (typeof self._size === \"number\") {\n    callback(null, self._size);\n    return;\n  }\n\n  self._size = self.buffer.length;\n  callback(null, self._size);\n};\n\n/**\n * @method DataMan.Buffer.prototype.type\n * @private\n *\n * Returns the type of the data.\n */\nDataMan.Buffer.prototype.type = function dataManBufferType() {\n  return this._type;\n};\n","/**\n * @method DataMan.DataURI\n * @public\n * @constructor\n * @param {String} dataUri\n */\nDataMan.DataURI = function DataManDataURI(dataUri) {\n  var self = this;\n  var pieces = dataUri.match(/^data:(.*);base64,(.*)$/);\n  var buffer = new Buffer(pieces[2], 'base64');\n  return new DataMan.Buffer(buffer, pieces[1]);\n};\n\nDataMan.DataURI.prototype = DataMan.Buffer.prototype;\n","var mime = Npm.require('mime');\nvar fs = Npm.require(\"fs\");\n\n/**\n * @method DataMan.FilePath\n * @public\n * @constructor\n * @param {String} filepath\n * @param {String} [type] The data content (MIME) type. Will lookup from file if not passed.\n */\nDataMan.FilePath = function DataManFilePath(filepath, type) {\n  var self = this;\n  self.filepath = filepath;\n  self._type = type || mime.lookup(filepath);\n};\n\n/**\n * @method DataMan.FilePath.prototype.getBuffer\n * @private\n * @param {function} callback callback(err, buffer)\n * @returns {Buffer|undefined}\n *\n * Passes a Buffer representing the data to a callback.\n */\nDataMan.FilePath.prototype.getBuffer = function dataManFilePathGetBuffer(callback) {\n  var self = this;\n\n  // Call node readFile\n  fs.readFile(self.filepath, Meteor.bindEnvironment(function(err, buffer) {\n    callback(err, buffer);\n  }, function(err) {\n    callback(err);\n  }));\n};\n\n/**\n * @method DataMan.FilePath.prototype.getDataUri\n * @private\n * @param {function} callback callback(err, dataUri)\n *\n * Passes a data URI representing the data to a callback.\n */\nDataMan.FilePath.prototype.getDataUri = function dataManFilePathGetDataUri(callback) {\n  var self = this;\n\n  self.getBuffer(function (error, buffer) {\n    if (error) {\n      callback(error);\n    } else {\n      if (!self._type) {\n        callback(new Error(\"DataMan.getDataUri couldn't get a contentType\"));\n      } else {\n        var dataUri = \"data:\" + self._type + \";base64,\" + buffer.toString(\"base64\");\n        buffer = null;\n        callback(null, dataUri);\n      }\n    }\n  });\n};\n\n/**\n * @method DataMan.FilePath.prototype.createReadStream\n * @private\n *\n * Returns a read stream for the data.\n */\nDataMan.FilePath.prototype.createReadStream = function dataManFilePathCreateReadStream() {\n  // Stream from filesystem\n  return fs.createReadStream(this.filepath);\n};\n\n/**\n * @method DataMan.FilePath.prototype.size\n * @param {function} callback callback(err, size)\n * @private\n *\n * Passes the size in bytes of the data to a callback.\n */\nDataMan.FilePath.prototype.size = function dataManFilePathSize(callback) {\n  var self = this;\n\n  if (typeof self._size === \"number\") {\n    callback(null, self._size);\n    return;\n  }\n\n  // We can get the size without buffering\n  fs.stat(self.filepath, Meteor.bindEnvironment(function (error, stats) {\n    if (stats && typeof stats.size === \"number\") {\n      self._size = stats.size;\n      callback(null, self._size);\n    } else {\n      callback(error);\n    }\n  }, function (error) {\n    callback(error);\n  }));\n};\n\n/**\n * @method DataMan.FilePath.prototype.type\n * @private\n *\n * Returns the type of the data.\n */\nDataMan.FilePath.prototype.type = function dataManFilePathType() {\n  return this._type;\n};\n","var request = Npm.require(\"request\");\n\n/**\n * @method DataMan.URL\n * @public\n * @constructor\n * @param {String} url\n * @param {String} type The data content (MIME) type.\n */\nDataMan.URL = function DataManURL(url, type, options) {\n  var self = this;\n  options = options || {};\n\n  self.url = url;\n  self._type = type;\n\n  // This is some code borrowed from the http package. Hopefully\n  // we can eventually use HTTP pkg directly instead of 'request'\n  // once it supports streams and buffers and such. (`request` takes\n  // and `auth` option, too, but not of the same form as `HTTP`.)\n  if (options.auth) {\n    if (options.auth.indexOf(':') < 0)\n      throw new Error('auth option should be of the form \"username:password\"');\n    options.headers = options.headers || {};\n    options.headers['Authorization'] = \"Basic \"+\n      (new Buffer(options.auth, \"ascii\")).toString(\"base64\");\n    delete options.auth;\n  }\n\n  self.urlOpts = options;\n};\n\n/**\n * @method DataMan.URL.prototype.getBuffer\n * @private\n * @param {function} callback callback(err, buffer)\n * @returns {Buffer|undefined}\n *\n * Passes a Buffer representing the data at the URL to a callback.\n */\nDataMan.URL.prototype.getBuffer = function dataManUrlGetBuffer(callback) {\n  var self = this;\n\n  request(_.extend({\n    url: self.url,\n    method: \"GET\",\n    encoding: null,\n    jar: false\n  }, self.urlOpts), Meteor.bindEnvironment(function(err, res, body) {\n    if (err) {\n      callback(err);\n    } else {\n      self._type = res.headers['content-type'];\n      callback(null, body);\n    }\n  }, function(err) {\n    callback(err);\n  }));\n};\n\n/**\n * @method DataMan.URL.prototype.getDataUri\n * @private\n * @param {function} callback callback(err, dataUri)\n *\n * Passes a data URI representing the data at the URL to a callback.\n */\nDataMan.URL.prototype.getDataUri = function dataManUrlGetDataUri(callback) {\n  var self = this;\n\n  self.getBuffer(function (error, buffer) {\n    if (error) {\n      callback(error);\n    } else {\n      if (!self._type) {\n        callback(new Error(\"DataMan.getDataUri couldn't get a contentType\"));\n      } else {\n        var dataUri = \"data:\" + self._type + \";base64,\" + buffer.toString(\"base64\");\n        callback(null, dataUri);\n      }\n    }\n  });\n};\n\n/**\n * @method DataMan.URL.prototype.createReadStream\n * @private\n *\n * Returns a read stream for the data.\n */\nDataMan.URL.prototype.createReadStream = function dataManUrlCreateReadStream() {\n  var self = this;\n  // Stream from URL\n  return request(_.extend({\n    url: self.url,\n    method: \"GET\"\n  }, self.urlOpts));\n};\n\n/**\n * @method DataMan.URL.prototype.size\n * @param {function} callback callback(err, size)\n * @private\n *\n * Returns the size in bytes of the data at the URL.\n */\nDataMan.URL.prototype.size = function dataManUrlSize(callback) {\n  var self = this;\n\n  if (typeof self._size === \"number\") {\n    callback(null, self._size);\n    return;\n  }\n\n  self.getBuffer(function (error, buffer) {\n    if (error) {\n      callback(error);\n    } else {\n      self._size = buffer.length;\n      callback(null, self._size);\n    }\n  });\n};\n\n/**\n * @method DataMan.URL.prototype.type\n * @private\n *\n * Returns the type of the data.\n */\nDataMan.URL.prototype.type = function dataManUrlType() {\n  return this._type;\n};\n","/* global DataMan */\n\nvar PassThrough = Npm.require('stream').PassThrough;\n\n/**\n * @method DataMan.ReadStream\n * @public\n * @constructor\n * @param {ReadStream} stream\n * @param {String} type The data content (MIME) type.\n */\nDataMan.ReadStream = function DataManBuffer(stream, type) {\n  var self = this;\n\n  // Create a bufferable / paused new stream...\n  var pt = new PassThrough();\n\n  // Pipe provided read stream into pass-through stream\n  stream.pipe(pt);\n\n  // Set pass-through stream reference\n  self.stream = pt;\n\n  // Set type as provided\n  self._type = type;\n};\n\n/**\n * @method DataMan.ReadStream.prototype.getBuffer\n * @private\n * @param {function} callback callback(err, buffer)\n * @returns {undefined}\n *\n * Passes a Buffer representing the data to a callback.\n */\nDataMan.ReadStream.prototype.getBuffer = function dataManReadStreamGetBuffer(/*callback*/) {\n  // TODO implement as passthrough stream?\n};\n\n/**\n * @method DataMan.ReadStream.prototype.getDataUri\n * @private\n * @param {function} callback callback(err, dataUri)\n *\n * Passes a data URI representing the data in the stream to a callback.\n */\nDataMan.ReadStream.prototype.getDataUri = function dataManReadStreamGetDataUri(/*callback*/) {\n  // TODO implement as passthrough stream?\n};\n\n/**\n * @method DataMan.ReadStream.prototype.createReadStream\n * @private\n *\n * Returns a read stream for the data.\n */\nDataMan.ReadStream.prototype.createReadStream = function dataManReadStreamCreateReadStream() {\n  return this.stream;\n};\n\n/**\n * @method DataMan.ReadStream.prototype.size\n * @param {function} callback callback(err, size)\n * @private\n *\n * Passes the size in bytes of the data in the stream to a callback.\n */\nDataMan.ReadStream.prototype.size = function dataManReadStreamSize(callback) {\n  callback(0); // will determine from stream later\n};\n\n/**\n * @method DataMan.ReadStream.prototype.type\n * @private\n *\n * Returns the type of the data.\n */\nDataMan.ReadStream.prototype.type = function dataManReadStreamType() {\n  return this._type;\n};\n"]}