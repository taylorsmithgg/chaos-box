{"version":3,"file":"/packages/ongoworks:security.js","sources":["ongoworks:security/security-util.js","ongoworks:security/security-deny.js","ongoworks:security/security-api.js","ongoworks:security/security-rules.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAAA,uB;;AAEA,sF;AACA,iB;AACA,yB;AACA,wB;AACA,G;AACA,8B;AACA,oB;AACA,K;AACA,oC;AACA,0B;AACA,K;AACA,E;;AAEA,e;AACA,U;AACA,e;AACA,e;AACA,c;AACA,I;AACA,S;AACA,e;AACA,e;AACA,c;AACA,G;AACA,E;AACA,+E;AACA,8B;AACA,sD;AACA,qD;AACA,O;AACA,6D;AACA,iE;AACA,sC;AACA,8C;AACA,O;AACA,K;AACA,E;;AAEA,sE;AACA,0D;AACA,gB;AACA,K;AACA,E;;;;;;;;;;;;;;;;;;;AC5CA,E;AACA,qG;AACA,0D;AACA,G;;AAEA,kE;AACA,8B;AACA,+C;AACA,4C;AACA,4D;AACA,wC;AACA,4D;;AAEA,oE;AACA,iD;AACA,4C;AACA,W;;AAEA,gG;AACA,gF;AACA,+C;AACA,oC;AACA,W;AACA,S;AACA,O;AACA,K;AACA,E;;;;;;;;;;;;;;;;;;;AC1BA,iE;AACA,Y;AACA,iD;AACA,oB;;AAEA,4B;AACA,sB;AACA,K;AACA,wB;AACA,4B;AACA,I;AACA,oC;AACA,kC;AACA,oC;AACA,I;AACA,kE;AACA,+E;AACA,wC;AACA,iG;AACA,K;AACA,gF;AACA,0C;AACA,0E;AACA,K;AACA,oD;AACA,sB;AACA,+B;AACA,+B;AACA,gB;AACA,S;AACA,kB;AACA,M;AACA,G;AACA,E;;AAEA,2B;AACA,8D;AACA,kB;AACA,oF;AACA,mF;AACA,gC;AACA,kD;AACA,kC;AACA,Y;AACA,0G;AACA,K;AACA,G;;AAEA,kC;;AAEA,uC;AACA,6C;AACA,6B;AACA,sD;AACA,oC;AACA,K;;AAEA,c;AACA,E;;AAEA,6C;AACA,kB;;AAEA,2C;AACA,uG;AACA,G;;AAEA,wF;AACA,gG;AACA,wF;AACA,oB;AACA,qD;;AAEA,yF;AACA,iG;AACA,iG;AACA,kC;AACA,mB;AACA,uD;AACA,oD;AACA,2D;AACA,sE;AACA,4E;AACA,O;AACA,O;;AAEA,mD;;AAEA,E;;AAEA,sD;AACA,kB;AACA,sF;AACA,kF;AACA,2D;AACA,yF;AACA,K;AACA,E;;AAEA,sD;AACA,kD;AACA,E;;;;;;;;;;;;;;;;;;;ACrGA,E;AACA,iD;AACA,G;;AAEA,E;AACA,S;AACA,G;;AAEA,gC;AACA,Y;AACA,8B;AACA,gB;AACA,G;AACA,G;;AAEA,E;AACA,Y;AACA,G;;AAEA,qC;AACA,Y;AACA,sC;AACA,mB;AACA,G;AACA,G;;AAEA,E;AACA,mB;AACA,G;;AAEA,sC;AACA,Y;AACA,sC;AACA,0B;AACA,G;AACA,G;;AAEA,E;AACA,iB;AACA,G;;AAEA,2C;;AAEA,8C;;AAEA,sC;AACA,c;AACA,wC;AACA,8C;AACA,K;AACA,K;;AAEA,C;;AAEA,E;AACA,sB;AACA,G;;AAEA,oC;AACA,Y;AACA,uD;AACA,0B;AACA,kB;AACA,K;;AAEA,2C;;AAEA,sD;AACA,wC;AACA,O;AACA,G;AACA,G;;AAEA,sC;AACA,Y;AACA,uD;AACA,0B;AACA,kB;AACA,K;;AAEA,2C;;AAEA,mD;AACA,wC;AACA,O;AACA,G;AACA,G","sourcesContent":["rulesByCollection = {};\n\naddFuncForAll = function addFuncForAll(collections, allowOrDeny, types, fetch, func) {\n  var rules = {};\n  if (_.isArray(fetch)) {\n    rules.fetch = fetch;\n  }\n  _.each(types, function (t) {\n    rules[t] = func;\n  });\n  _.each(collections, function (c) {\n    c[allowOrDeny](rules);\n  });\n};\n\nvar created = {\n  allow: {\n    insert: {},\n    update: {},\n    remove: {}\n  },\n  deny: {\n    insert: {},\n    update: {},\n    remove: {}\n  }\n};\nensureCreated = function ensureCreated(allowOrDeny, collections, types, func) {\n  _.each(types, function (t) {\n    collections = _.reject(collections, function (c) {\n      return _.has(created[allowOrDeny][t], c._name);\n    });\n    addFuncForAll(collections, allowOrDeny, [t], null, func);\n    // mark that we've defined function for collection-type combo\n    _.each(collections, function (c) {\n      created[allowOrDeny][t][c._name] = true;\n    });\n  });\n};\n\nensureDefaultAllow = function ensureDefaultAllow(collections, types) {\n  ensureCreated(\"allow\", collections, types, function () {\n    return true;\n  });\n};\n","/*\n * A single deny function runs all the deny functions registered by this package, allowing us to have\n * an OR relationship among multiple security rule chains.\n */\n\nensureSecureDeny = function ensureSecureDeny(collections, types) {\n  _.each(types, function (t) {\n    _.each(collections, function (collection) {\n      var collectionName = collection._name;\n      ensureCreated(\"deny\", [collection], [t], function () {\n        var args = _.toArray(arguments);\n        var rules = rulesByCollection[collectionName] || [];\n\n        // select only those rules that apply to this operation type\n        rules = _.select(rules, function (rule) {\n          return _.contains(rule._types, t);\n        });\n\n        // Loop through all defined rules for this collection. There is an OR relationship among\n        // all rules for the collection, so if any do NOT return true, we allow.\n        return _.every(rules, function (rule) {\n          return rule.deny(t, args);\n        });\n      });\n    });\n  });\n};\n","// The `Security` object is exported and provides the package API\nSecurity = {\n  Rule: function SecurityRuleConstructor(types) {\n    var self = this;\n\n    if (!_.isArray(types)) {\n      types = [types];\n    }\n    self._types = types;\n    self._restrictions = [];\n  },\n  // the starting point of the chain\n  permit: function permit(types) {\n    return new Security.Rule(types);\n  },\n  defineMethod: function Security_defineMethod(name, definition) {\n    // Check whether a rule with the given name already exists; can't overwrite\n    if (Security.Rule.prototype[name]) {\n      throw new Error('A security method with the name \"' + name + '\" has already been defined');\n    }\n    // Make sure the definition argument is an object that has a `deny` property\n    if (!definition || !definition.deny) {\n      throw new Error('Security.defineMethod requires a \"deny\" function');\n    }\n    Security.Rule.prototype[name] = function (arg) {\n      var self = this;\n      self._restrictions.push({\n        definition: definition,\n        arg: arg\n      });\n      return self;\n    };\n  }\n};\n\n// Security.Rule prototypes\nSecurity.Rule.prototype.collections = function (collections) {\n  var self = this;\n  // Make sure the `collections` argument is either a `Mongo.Collection` instance or\n  // an array of them. If it's a single collection, convert it to a one-item array.\n  if (!_.isArray(collections)) {\n    if (collections instanceof Mongo.Collection) {\n      collections = [collections];\n    } else {\n      throw new Error(\"The collections argument must be a Mongo.Collection instance or an array of them\");\n    }\n  }\n\n  self._collections = collections;\n\n  // Keep list keyed by collection name\n  _.each(collections, function (collection) {\n    var n = collection._name;\n    rulesByCollection[n] = rulesByCollection[n] || [];\n    rulesByCollection[n].push(self);\n  });\n\n  return self;\n};\n\nSecurity.Rule.prototype.apply = function () {\n  var self = this;\n\n  if (!self._collections || !self._types) {\n    throw new Error(\"At a minimum, you must call permit and collections methods for a security rule.\");\n  }\n\n  // If we haven't yet done so, set up a default, permissive `allow` function for all of\n  // the given collections and types. We control all security through `deny` functions only, but\n  // there must first be at least one `allow` function for each collection or all writes\n  // will be denied.\n  ensureDefaultAllow(self._collections, self._types);\n\n  // We need a combined `fetch` array. The `fetch` is optional and can be either an array\n  // or a function that takes the argument passed to the restriction method and returns an array.\n  // TODO for now we can't set fetch accurately; maybe need to adjust API so that we \"apply\" only\n  // after we've defined all rules\n  //var fetch = [];\n  //_.each(self._restrictions, function (restriction) {\n  //  if (_.isArray(restriction.definition.fetch)) {\n  //    fetch = fetch.concat(restriction.definition.fetch);\n  //  } else if (typeof restriction.definition.fetch === \"function\") {\n  //    fetch = fetch.concat(restriction.definition.fetch(restriction.arg));\n  //  }\n  //});\n\n  ensureSecureDeny(self._collections, self._types);\n\n};\n\nSecurity.Rule.prototype.deny = function (type, args) {\n  var self = this;\n  // Loop through all defined restrictions. Restrictions are additive for this chained\n  // rule, so if any deny function returns true, this function should return true.\n  return _.any(self._restrictions, function (restriction) {\n    return restriction.definition.deny.apply(this, [type, restriction.arg].concat(args));\n  });\n};\n\nMongo.Collection.prototype.permit = function (types) {\n  return Security.permit(types).collections(this);\n};\n","/*\n * This file defines built-in restriction methods\n */\n\n/*\n * No one\n */\n\nSecurity.defineMethod(\"never\", {\n  fetch: [],\n  deny: function (type, arg) {\n    return true;\n  }\n});\n\n/*\n * Logged In\n */\n\nSecurity.defineMethod(\"ifLoggedIn\", {\n  fetch: [],\n  deny: function (type, arg, userId) {\n    return !userId;\n  }\n});\n\n/*\n * Specific User ID\n */\n\nSecurity.defineMethod(\"ifHasUserId\", {\n  fetch: [],\n  deny: function (type, arg, userId) {\n    return userId !== arg;\n  }\n});\n\n/*\n * Specific Roles\n */\n\nif (Package && Package[\"alanning:roles\"]) {\n\n  var Roles = Package[\"alanning:roles\"].Roles;\n\n  Security.defineMethod(\"ifHasRole\", {\n    fetch: [],\n    deny: function (type, arg, userId) {\n      return !Roles.userIsInRole(userId, arg);\n    }\n  });\n\n}\n\n/*\n * Specific Properties\n */\n\nSecurity.defineMethod(\"onlyProps\", {\n  fetch: [],\n  deny: function (type, arg, userId, doc, fieldNames) {\n    if (!_.isArray(arg)) {\n      arg = [arg];\n    }\n\n    fieldNames = fieldNames || _.keys(doc);\n\n    return !_.every(fieldNames, function (fieldName) {\n      return _.contains(arg, fieldName);\n    });\n  }\n});\n\nSecurity.defineMethod(\"exceptProps\", {\n  fetch: [],\n  deny: function (type, arg, userId, doc, fieldNames) {\n    if (!_.isArray(arg)) {\n      arg = [arg];\n    }\n\n    fieldNames = fieldNames || _.keys(doc);\n\n    return _.any(fieldNames, function (fieldName) {\n      return _.contains(arg, fieldName);\n    });\n  }\n});\n"]}