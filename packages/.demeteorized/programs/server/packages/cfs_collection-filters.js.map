{"version":3,"sources":["cfs:collection-filters/filters.js"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA,G;AACA,0C;AACA,U;AACA,8D;AACA,uB;AACA,G;AACA,kE;AACA,kB;;AAEA,6E;AACA,gB;AACA,8B;AACA,wD;AACA,2B;AACA,2B;AACA,qD;AACA,4D;AACA,O;AACA,O;;AAEA,2B;AACA,iD;AACA,6B;AACA,wE;AACA,0D;AACA,K;;AAEA,8B;AACA,wD;AACA,sC;AACA,sC;AACA,iE;AACA,oF;AACA,c;AACA,kC;AACA,4E;AACA,kF;AACA,S;AACA,O;AACA,O;;AAEA,iC;AACA,wD;AACA,wC;AACA,wC;AACA,mE;AACA,yF;AACA,O;AACA,O;;AAEA,kC;AACA,G;;AAEA,gE;AACA,+D;AACA,mB;AACA,sC;AACA,sC;AACA,M;AACA,wD;AACA,8D;AACA,6D;AACA,sE;AACA,oF;AACA,sC;AACA,M;AACA,a;AACA,K;;AAEA,0E;AACA,gE;AACA,oC;AACA,gB;AACA,0B;AACA,oB;AACA,Q;AACA,0B;AACA,oB;AACA,Q;AACA,0B;AACA,oB;AACA,Q;AACA,4B;AACA,oB;AACA,Q;AACA,gB;AACA,qB;AACA,O;AACA,G;AACA,qE;AACA,sE;AACA,0E;AACA,2E;AACA,qD;AACA,E;;AAEA,G;AACA,2F;AACA,U;AACA,8D;AACA,E;AACA,gE;AACA,wE;AACA,+D;AACA,sE;AACA,U;AACA,G;AACA,wE;AACA,kB;;AAEA,gB;AACA,mC;AACA,gB;AACA,gB;AACA,G;AACA,qE;AACA,qE;;AAEA,4B;AACA,gC;AACA,mC;AACA,6C;AACA,oF;AACA,iB;AACA,G;AACA,gC;AACA,qC;AACA,iF;AACA,iB;AACA,G;;AAEA,mD;AACA,iB;AACA,qC;AACA,mC;AACA,uE;AACA,sE;AACA,gH;AACA,mB;AACA,K;AACA,G;;AAEA,2B;AACA,+B;AACA,uE;AACA,uE;AACA,mH;AACA,iB;AACA,G;;AAEA,sB;AACA,wE;AACA,mE;AACA,iB;AACA,G;AACA,c;AACA,E;;AAEA,G;AACA,oE;AACA,W;AACA,kD;AACA,iD;AACA,qB;AACA,E;AACA,oE;AACA,yD;AACA,G;AACA,+C;AACA,8B;AACA,kD;AACA,uB;AACA,mC;AACA,mB;AACA,Y;AACA,K;AACA,wE;AACA,mB;AACA,Y;AACA,K;AACA,wE;AACA,mB;AACA,Y;AACA,K;AACA,wE;AACA,mB;AACA,Y;AACA,K;AACA,G;AACA,e;AACA,C","file":"/packages/cfs:collection-filters.js","sourcesContent":["/**\n * @method FS.Collection.prototype.filters\n * @public\n * @param {Object} filters - File filters for this collection.\n * @returns {undefined}\n */\nFS.Collection.prototype.filters = function fsColFilters(filters) {\n  var self = this;\n\n  // Check filter option values and normalize them for quicker checking later\n  if (filters) {\n    // check/adjust allow/deny\n    FS.Utility.each(['allow', 'deny'], function (type) {\n      if (!filters[type]) {\n        filters[type] = {};\n      } else if (typeof filters[type] !== \"object\") {\n        throw new Error(type + ' filter must be an object');\n      }\n    });\n\n    // check/adjust maxSize\n    if (typeof filters.maxSize === \"undefined\") {\n      filters.maxSize = null;\n    } else if (filters.maxSize && typeof filters.maxSize !== \"number\") {\n      throw new Error('maxSize filter must be an number');\n    }\n\n    // check/adjust extensions\n    FS.Utility.each(['allow', 'deny'], function (type) {\n      if (!filters[type].extensions) {\n        filters[type].extensions = [];\n      } else if (!FS.Utility.isArray(filters[type].extensions)) {\n        throw new Error(type + '.extensions filter must be an array of extensions');\n      } else {\n        //convert all to lowercase\n        for (var i = 0, ln = filters[type].extensions.length; i < ln; i++) {\n          filters[type].extensions[i] = filters[type].extensions[i].toLowerCase();\n        }\n      }\n    });\n\n    // check/adjust content types\n    FS.Utility.each(['allow', 'deny'], function (type) {\n      if (!filters[type].contentTypes) {\n        filters[type].contentTypes = [];\n      } else if (!FS.Utility.isArray(filters[type].contentTypes)) {\n        throw new Error(type + '.contentTypes filter must be an array of content types');\n      }\n    });\n\n    self.options.filter = filters;\n  }\n\n  // Define deny functions to enforce file filters on the server\n  // for inserts and updates that initiate from untrusted code.\n  self.files.deny({\n    insert: function(userId, fsFile) {\n      return !self.allowsFile(fsFile);\n    },\n    update: function(userId, fsFile, fields, modifier) {\n      // TODO will need some kind of additional security here:\n      // Don't allow them to change the type, size, name, and\n      // anything else that would be security or data integrity issue.\n      // Such security should probably be added by cfs-collection package, not here.\n      return !self.allowsFile(fsFile);\n    },\n    fetch: []\n  });\n\n  // If insecure package is in use, we need to add allow rules that return\n  // true. Otherwise, it would seemingly turn off insecure mode.\n  if (Package && Package.insecure) {\n    self.allow({\n      insert: function() {\n        return true;\n      },\n      update: function() {\n        return true;\n      },\n      remove: function() {\n        return true;\n      },\n      download: function() {\n        return true;\n      },\n      fetch: [],\n      transform: null\n    });\n  }\n  // If insecure package is NOT in use, then adding the deny function\n  // does not have any effect on the main app's security paradigm. The\n  // user will still be required to add at least one allow function of her\n  // own for each operation for this collection. And the user may still add\n  // additional deny functions, but does not have to.\n};\n\n/**\n * @method FS.Collection.prototype.allowsFile Does the collection allow the specified file?\n * @public\n * @returns {boolean} True if the collection allows this file.\n *\n * Checks based on any filters defined on the collection. If the\n * file is not valid according to the filters, this method returns false\n * and also calls the filter `onInvalid` method defined for the\n * collection, passing it an English error string that explains why it\n * failed.\n */\nFS.Collection.prototype.allowsFile = function fsColAllowsFile(fileObj) {\n  var self = this;\n\n  // Get filters\n  var filter = self.options.filter;\n  if (!filter) {\n    return true;\n  }\n  var saveAllFileExtensions = (filter.allow.extensions.length === 0);\n  var saveAllContentTypes = (filter.allow.contentTypes.length === 0);\n\n  // Get info about the file\n  var filename = fileObj.name();\n  var contentType = fileObj.type();\n  if (!saveAllContentTypes && !contentType) {\n    filter.onInvalid && filter.onInvalid(filename + \" has an unknown content type\");\n    return false;\n  }\n  var fileSize = fileObj.size();\n  if (!fileSize || isNaN(fileSize)) {\n    filter.onInvalid && filter.onInvalid(filename + \" has an unknown file size\");\n    return false;\n  }\n\n  // Do extension checks only if we have a filename\n  if (filename) {\n    var ext = fileObj.getExtension();\n    if (!((saveAllFileExtensions ||\n            FS.Utility.indexOf(filter.allow.extensions, ext) !== -1) &&\n            FS.Utility.indexOf(filter.deny.extensions, ext) === -1)) {\n      filter.onInvalid && filter.onInvalid(filename + ' has the extension \"' + ext + '\", which is not allowed');\n      return false;\n    }\n  }\n\n  // Do content type checks\n  if (!((saveAllContentTypes ||\n          contentTypeInList(filter.allow.contentTypes, contentType)) &&\n          !contentTypeInList(filter.deny.contentTypes, contentType))) {\n    filter.onInvalid && filter.onInvalid(filename + ' is of the type \"' + contentType + '\", which is not allowed');\n    return false;\n  }\n\n  // Do max size check\n  if (typeof filter.maxSize === \"number\" && fileSize > filter.maxSize) {\n    filter.onInvalid && filter.onInvalid(filename + \" is too big\");\n    return false;\n  }\n  return true;\n};\n\n/**\n * @method contentTypeInList Is the content type string in the list?\n * @private\n * @param {String[]} list - Array of content types\n * @param {String} contentType - The content type\n * @returns {Boolean}\n *\n * Returns true if the content type is in the list, or if it matches\n * one of the special types in the list, e.g., \"image/*\".\n */\nfunction contentTypeInList(list, contentType) {\n  var listType, found = false;\n  for (var i = 0, ln = list.length; i < ln; i++) {\n    listType = list[i];\n    if (listType === contentType) {\n      found = true;\n      break;\n    }\n    if (listType === \"image/*\" && contentType.indexOf(\"image/\") === 0) {\n      found = true;\n      break;\n    }\n    if (listType === \"audio/*\" && contentType.indexOf(\"audio/\") === 0) {\n      found = true;\n      break;\n    }\n    if (listType === \"video/*\" && contentType.indexOf(\"video/\") === 0) {\n      found = true;\n      break;\n    }\n  }\n  return found;\n}\n"]}