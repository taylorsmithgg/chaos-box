{"version":3,"sources":["cfs:gridfs/gridfs.server.js"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA,+B;AACA,qC;AACA,+C;AACA,wC;AACA,kD;;AAEA,0G;;AAEA,G;AACA,U;AACA,e;AACA,wC;AACA,0B;AACA,iN;AACA,4E;AACA,iE;AACA,E;AACA,iF;AACA,Q;AACA,G;;AAEA,2C;AACA,kB;AACA,0B;;AAEA,wB;AACA,gD;;AAEA,yC;AACA,6D;;AAEA,0B;AACA,6C;AACA,4E;AACA,sC;AACA,G;;AAEA,8B;AACA,4F;AACA,G;;AAEA,0B;AACA,kC;AACA,G;;AAEA,+C;;AAEA,+B;AACA,gC;AACA,wE;AACA,uE;AACA,iB;AACA,kB;AACA,sB;AACA,Q;;AAEA,6E;AACA,oB;AACA,0E;AACA,mC;AACA,iI;AACA,O;;AAEA,8F;AACA,iB;AACA,M;AACA,kD;AACA,8B;;AAEA,oB;AACA,2C;;AAEA,4C;AACA,sB;AACA,uC;AACA,wB;AACA,Q;;AAEA,+C;AACA,wF;AACA,2B;AACA,0B;AACA,kC;AACA,6B;AACA,U;AACA,O;;AAEA,kD;;AAEA,4C;;AAEA,M;AACA,mD;AACA,8B;;AAEA,oB;AACA,2C;;AAEA,kB;AACA,mC;AACA,kB;AACA,yB;AACA,oD;AACA,yE;AACA,kB;AACA,uC;AACA,2C;AACA,uE;AACA,Q;;AAEA,wB;AACA,6C;AACA,O;;AAEA,oD;;AAEA,8C;AACA,oB;AACA,mE;AACA,kE;AACA,mE;AACA,iB;AACA,S;;AAEA,uD;;AAEA,kE;AACA,oC;AACA,kF;AACA,mF;AACA,4E;AACA,+E;AACA,0C;AACA,uC;AACA,4B;AACA,iD;AACA,W;AACA,S;;AAEA,+C;AACA,iD;AACA,S;;AAEA,yB;;AAEA,M;AACA,yC;AACA,oB;AACA,2C;;AAEA,W;AACA,mF;AACA,oB;AACA,sB;AACA,O;AACA,M;;AAEA,sB;AACA,uB;AACA,iF;AACA,M;;AAEA,8B;AACA,sF;AACA,0C;AACA,qB;AACA,uB;AACA,S;AACA,K;AACA,K;AACA,E","file":"/packages/cfs_gridfs.js","sourcesContent":["var path = Npm.require('path');\nvar mongodb = Npm.require('mongodb');\nvar ObjectID = Npm.require('mongodb').ObjectID;\nvar Grid = Npm.require('gridfs-stream');\n//var Grid = Npm.require('gridfs-locking-stream');\n\nvar chunkSize = 1024*1024*2; // 256k is default GridFS chunk size, but performs terribly for largish files\n\n/**\n * @public\n * @constructor\n * @param {String} name - The store name\n * @param {Object} options\n * @param {Function} [options.beforeSave] - Function to run before saving a file from the server. The context of the function will be the `FS.File` instance we're saving. The function may alter its properties.\n * @param {Number} [options.maxTries=5] - Max times to attempt saving a file\n * @returns {FS.StorageAdapter} An instance of FS.StorageAdapter.\n *\n * Creates a GridFS store instance on the server. Inherits from FS.StorageAdapter\n * type.\n */\n\nFS.Store.GridFS = function(name, options) {\n  var self = this;\n  options = options || {};\n\n  var gridfsName = name;\n  var mongoOptions = options.mongoOptions || {};\n\n  if (!(self instanceof FS.Store.GridFS))\n    throw new Error('FS.Store.GridFS missing keyword \"new\"');\n\n  if (!options.mongoUrl) {\n    options.mongoUrl = process.env.MONGO_URL;\n    // When using a Meteor MongoDB instance, preface name with \"cfs_gridfs.\"\n    gridfsName = \"cfs_gridfs.\" + name;\n  }\n\n  if (!options.mongoOptions) {\n    options.mongoOptions = { db: { native_parser: true }, server: { auto_reconnect: true }};\n  }\n\n  if (options.chunkSize) {\n    chunkSize = options.chunkSize;\n  }\n\n  return new FS.StorageAdapter(name, options, {\n\n    typeName: 'storage.gridfs',\n    fileKey: function(fileObj) {\n      // We should not have to mount the file here - We assume its taken\n      // care of - Otherwise we create new files instead of overwriting\n      var key = {\n        _id: null,\n        filename: null\n      };\n\n      // If we're passed a fileObj, we retrieve the _id and filename from it.\n      if (fileObj) {\n        var info = fileObj._getInfo(name, {updateFileRecordFirst: false});\n        key._id = info.key || null;\n        key.filename = info.name || fileObj.name({updateFileRecordFirst: false}) || (fileObj.collectionName + '-' + fileObj._id);\n      }\n\n      // If key._id is null at this point, createWriteStream will let GridFS generate a new ID\n      return key;\n    },\n    createReadStream: function(fileKey, options) {\n      options = options || {};\n\n      // Init GridFS\n      var gfs = new Grid(self.db, mongodb);\n\n      // Set the default streamning settings\n      var settings = {\n        _id: new ObjectID(fileKey._id),\n        root: gridfsName\n      };\n\n      // Check if this should be a partial read\n      if (typeof options.start !== 'undefined' && typeof options.end !== 'undefined' ) {\n        // Add partial info\n        settings.range = {\n          startPos: options.start,\n          endPos: options.end\n        };\n      }\n\n      FS.debug && console.log('GRIDFS', settings);\n\n      return gfs.createReadStream(settings);\n\n    },\n    createWriteStream: function(fileKey, options) {\n      options = options || {};\n\n      // Init GridFS\n      var gfs = new Grid(self.db, mongodb);\n\n      var opts = {\n        filename: fileKey.filename,\n        mode: 'w',\n        root: gridfsName,\n        chunk_size: options.chunk_size || chunkSize,\n        // We allow aliases, metadata and contentType to be passed in via\n        // options\n        aliases: options.aliases || [],\n        metadata: options.metadata || null,\n        content_type: options.contentType || 'application/octet-stream'\n      };\n\n      if (fileKey._id) {\n        opts._id = new ObjectID(fileKey._id);\n      }\n\n      var writeStream = gfs.createWriteStream(opts);\n\n      writeStream.on('close', function(file) {\n        if (!file) {\n          // gridfs-stream will emit \"close\" without passing a file\n          // if there is an error. We can simply exit here because\n          // the \"error\" listener will also be called in this case.\n          return;\n        }\n\n        if (FS.debug) console.log('SA GridFS - DONE!');\n\n        // Emit end and return the fileKey, size, and updated date\n        writeStream.emit('stored', {\n          // Set the generated _id so that we know it for future reads and writes.\n          // We store the _id as a string and only convert to ObjectID right before\n          // reading, writing, or deleting. If we store the ObjectID itself,\n          // Meteor (EJSON?) seems to convert it to a LocalCollection.ObjectID,\n          // which GFS doesn't understand.\n          fileKey: file._id.toString(),\n          size: file.length,\n          storedAt: file.uploadDate || new Date()\n        });\n      });\n\n      writeStream.on('error', function(error) {\n        console.log('SA GridFS - ERROR!', error);\n      });\n\n      return writeStream;\n\n    },\n    remove: function(fileKey, callback) {\n      // Init GridFS\n      var gfs = new Grid(self.db, mongodb);\n\n      try {\n        gfs.remove({ _id: new ObjectID(fileKey._id), root: gridfsName }, callback);\n      } catch(err) {\n        callback(err);\n      }\n    },\n\n    // Not implemented\n    watch: function() {\n      throw new Error(\"GridFS storage adapter does not support the sync option\");\n    },\n\n    init: function(callback) {\n      mongodb.MongoClient.connect(options.mongoUrl, mongoOptions, function (err, db) {\n        if (err) { return callback(err); }\n        self.db = db;\n        callback(null);\n      });\n    }\n  });\n};\n"]}