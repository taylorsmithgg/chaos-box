{"version":3,"file":"/packages/cfs:storage-adapter.js","sources":["cfs:storage-adapter/storageAdapter.server.js","cfs:storage-adapter/transform.server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,gF;AACA,E;AACA,kB;AACA,E;AACA,gF;AACA,sB;;AAEA,uD;AACA,kB;AACA,0B;;AAEA,yE;AACA,gC;AACA,+D;AACA,6D;AACA,uC;;AAEA,0E;AACA,mC;AACA,8D;AACA,G;AACA,E;AACA,2G;AACA,2C;AACA,wG;AACA,K;AACA,K;;AAEA,0E;AACA,6D;AACA,0D;AACA,qE;AACA,G;;AAEA,iD;AACA,2D;AACA,wE;AACA,U;AACA,uC;AACA,G;;AAEA,wD;AACA,mD;AACA,4C;AACA,U;AACA,mC;AACA,G;;AAEA,sD;AACA,uC;AACA,wC;;AAEA,4C;AACA,oC;AACA,oB;AACA,0B;AACA,K;;AAEA,gD;AACA,oB;;AAEA,4C;AACA,iC;AACA,I;;AAEA,uC;AACA,wE;AACA,uE;AACA,2E;AACA,I;;AAEA,uC;AACA,8D;AACA,6D;AACA,wB;AACA,uC;AACA,uE;AACA,K;AACA,uF;AACA,I;;AAEA,uC;AACA,mB;AACA,sC;AACA,2D;AACA,S;;AAEA,qC;AACA,0D;AACA,S;;AAEA,mC;AACA,wD;AACA,S;;AAEA,sC;AACA,2D;AACA,S;;AAEA,0C;AACA,kG;AACA,S;AACA,K;AACA,G;;AAEA,wC;AACA,yE;AACA,wE;AACA,uF;;AAEA,oC;;AAEA,uB;AACA,I;;AAEA,wC;AACA,+D;AACA,iG;AACA,I;AACA,wB;AACA,uC;AACA,wE;AACA,K;;AAEA,kE;AACA,+D;AACA,+D;AACA,oC;AACA,4C;AACA,oE;AACA,K;AACA,4C;AACA,oE;AACA,K;AACA,4C;AACA,oE;AACA,K;;AAEA,iE;AACA,gE;AACA,wD;AACA,wD;AACA,sB;AACA,6C;AACA,4C;AACA,oC;AACA,oF;AACA,sC;AACA,0E;AACA,S;AACA,+B;AACA,0E;AACA,S;AACA,O;AACA,K;;AAEA,mG;;AAEA,oC;;AAEA,4E;AACA,M;AACA,gF;AACA,qB;AACA,mD;AACA,kD;AACA,mG;AACA,O;AACA,yE;AACA,wB;AACA,qD;;AAEA,gG;AACA,4C;AACA,qD;AACA,O;;AAEA,4D;AACA,0E;;AAEA,qE;AACA,uE;AACA,kF;AACA,O;;AAEA,sC;AACA,O;;AAEA,0B;AACA,iD;AACA,sF;AACA,0D;AACA,4D;AACA,iC;AACA,sP;AACA,O;AACA,O;;AAEA,6C;AACA,4C;AACA,sF;AACA,0D;AACA,kE;AACA,iC;AACA,2B;AACA,O;AACA,O;;AAEA,uB;AACA,I;;AAEA,Y;AACA,mD;AACA,qC;AACA,6C;AACA,I;;AAEA,K;AACA,+C;AACA,Y;AACA,+D;AACA,sF;AACA,I;AACA,6E;AACA,qD;AACA,K;AACA,qD;AACA,4C;;AAEA,sB;AACA,yF;;AAEA,mB;AACA,2E;AACA,Y;AACA,2D;AACA,K;AACA,I;;AAEA,6C;AACA,2B;AACA,gF;AACA,kD;AACA,I;;AAEA,uC;AACA,6C;AACA,G;;AAEA,4D;AACA,sC;AACA,0B;AACA,yC;AACA,2C;AACA,wC;AACA,K;;AAEA,E;;AAEA,8D;;;;;;;;;;;;;;;;;;ACnQA,oD;;AAEA,kC;AACA,kB;;AAEA,0B;;AAEA,sC;AACA,0E;;AAEA,uB;AACA,gF;;AAEA,iC;;AAEA,8C;AACA,+C;AACA,6C;AACA,E;;AAEA,8B;AACA,sB;AACA,sB;AACA,uC;AACA,4G;AACA,iC;AACA,gH;AACA,qC;AACA,G;AACA,wB;AACA,E;;AAEA,gF;AACA,sB;AACA,uE;AACA,kB;;AAEA,qB;AACA,8C;;AAEA,qB;AACA,6E;AACA,8E;AACA,+E;AACA,iC;AACA,8B;AACA,gC;AACA,8B;AACA,K;;AAEA,kD;;AAEA,6B;AACA,yC;;AAEA,gE;AACA,qD;AACA,0C;AACA,O;;AAEA,oB;AACA,S;AACA,6F;AACA,+E;AACA,kB;AACA,qD;AACA,wF;AACA,gB;AACA,K;;AAEA,0B;AACA,wB;AACA,U;;AAEA,iD;AACA,6B;AACA,G;;AAEA,E;;AAEA,sE;AACA,kB;;AAEA,gF;AACA,8C;AACA,qB;AACA,uE;AACA,M;AACA,yC;;AAEA,qB;AACA,8C;;AAEA,oB;AACA,+E;;AAEA,iD;AACA,uB;AACA,8C;;AAEA,oB;AACA,S;AACA,4F;AACA,kB;AACA,6B;AACA,qD;AACA,4F;AACA,K;;AAEA,0B;AACA,6B;;AAEA,G;;AAEA,+C;AACA,sB;AACA,E","sourcesContent":["// #############################################################################\n//\n// STORAGE ADAPTER\n//\n// #############################################################################\n_storageAdapters = {};\n\nFS.StorageAdapter = function(storeName, options, api) {\n  var self = this;\n  options = options || {};\n\n  // If storeName is the only argument, a string and the SA already found\n  // we will just return that SA\n  if (arguments.length === 1 && storeName === '' + storeName &&\n          typeof _storageAdapters[storeName] !== 'undefined')\n    return _storageAdapters[storeName];\n\n  // Verify that the storage adapter defines all the necessary API methods\n  if (typeof api === 'undefined') {\n    throw new Error('FS.StorageAdapter please define an api');\n  }\n  \n  FS.Utility.each('fileKey,remove,typeName,createReadStream,createWriteStream'.split(','), function(name) {\n    if (typeof api[name] === 'undefined') {\n      throw new Error('FS.StorageAdapter please define an api. \"' + name + '\" ' + (api.typeName || ''));\n    }\n  });\n\n  // Create an internal namespace, starting a name with underscore is only\n  // allowed for stores marked with options.internal === true\n  if (options.internal !== true && storeName[0] === '_') {\n    throw new Error('A storage adapter name may not begin with \"_\"');\n  }\n\n  // store reference for easy lookup by storeName\n  if (typeof _storageAdapters[storeName] !== 'undefined') {\n    throw new Error('Storage name already exists: \"' + storeName + '\"');\n  } else {\n    _storageAdapters[storeName] = self;\n  }\n\n  // User can customize the file key generation function\n  if (typeof options.fileKeyMaker === \"function\") {\n    var fileKeyMaker = options.fileKeyMaker;\n  } else {\n    var fileKeyMaker = api.fileKey;\n  }\n\n  // User can provide a function to adjust the fileObj\n  // before it is written to the store.\n  var beforeWrite = options.beforeWrite;\n\n  // extend self with options and other info\n  FS.Utility.extend(this, options, {\n    name: storeName,\n    typeName: api.typeName\n  });\n\n  // Create a nicer abstracted adapter interface\n  self.adapter = {};\n\n  self.adapter.fileKey = function(fileObj) {\n    return fileKeyMaker(fileObj);\n  };\n\n  // Return readable stream for fileKey\n  self.adapter.createReadStreamForFileKey = function(fileKey, options) {\n    FS.debug && console.log('createReadStreamForFileKey ' + storeName);\n    return FS.Utility.safeStream( api.createReadStream(fileKey, options) );\n  };\n\n  // Return readable stream for fileObj\n  self.adapter.createReadStream = function(fileObj, options) {\n    FS.debug && console.log('createReadStream ' + storeName);\n    if (self.internal) {\n      // Internal stores take a fileKey\n      return self.adapter.createReadStreamForFileKey(fileObj, options);\n    }\n    return FS.Utility.safeStream( self._transform.createReadStream(fileObj, options) );\n  };\n\n  function logEventsForStream(stream) {\n    if (FS.debug) {\n      stream.on('stored', function() {\n        console.log('-----------STORED STREAM', storeName);\n      });\n\n      stream.on('close', function() {\n        console.log('-----------CLOSE STREAM', storeName);\n      });\n\n      stream.on('end', function() {\n        console.log('-----------END STREAM', storeName);\n      });\n\n      stream.on('finish', function() {\n        console.log('-----------FINISH STREAM', storeName);\n      });\n\n      stream.on('error', function(error) {\n        console.log('-----------ERROR STREAM', storeName, error && (error.message || error.code));\n      });\n    }\n  }\n\n  // Return writeable stream for fileKey\n  self.adapter.createWriteStreamForFileKey = function(fileKey, options) {\n    FS.debug && console.log('createWriteStreamForFileKey ' + storeName);\n    var writeStream = FS.Utility.safeStream( api.createWriteStream(fileKey, options) );\n\n    logEventsForStream(writeStream);\n\n    return writeStream;\n  };\n\n  // Return writeable stream for fileObj\n  self.adapter.createWriteStream = function(fileObj, options) {\n    FS.debug && console.log('createWriteStream ' + storeName + ', internal: ' + !!self.internal);\n    \n    if (self.internal) {\n      // Internal stores take a fileKey\n      return self.adapter.createWriteStreamForFileKey(fileObj, options);\n    }\n\n    // If we haven't set name, type, or size for this version yet,\n    // set it to same values as original version. We don't save\n    // these to the DB right away because they might be changed\n    // in a transformWrite function.\n    if (!fileObj.name({store: storeName})) {\n      fileObj.name(fileObj.name(), {store: storeName, save: false});\n    }\n    if (!fileObj.type({store: storeName})) {\n      fileObj.type(fileObj.type(), {store: storeName, save: false});\n    }\n    if (!fileObj.size({store: storeName})) {\n      fileObj.size(fileObj.size(), {store: storeName, save: false});\n    }\n\n    // Call user function to adjust file metadata for this store.\n    // We support updating name, extension, and/or type based on\n    // info returned in an object. Or `fileObj` could be\n    // altered directly within the beforeWrite function.\n    if (beforeWrite) {\n      var fileChanges = beforeWrite(fileObj);\n      if (typeof fileChanges === \"object\") {\n        if (fileChanges.extension) {\n          fileObj.extension(fileChanges.extension, {store: storeName, save: false});\n        } else if (fileChanges.name) {\n          fileObj.name(fileChanges.name, {store: storeName, save: false});\n        }\n        if (fileChanges.type) {\n          fileObj.type(fileChanges.type, {store: storeName, save: false});\n        }\n      }\n    }\n\n    var writeStream = FS.Utility.safeStream( self._transform.createWriteStream(fileObj, options) );\n\n    logEventsForStream(writeStream);\n\n    // Its really only the storage adapter who knows if the file is uploaded\n    //\n    // We have to use our own event making sure the storage process is completed\n    // this is mainly\n    writeStream.safeOn('stored', function(result) {\n      if (typeof result.fileKey === 'undefined') {\n        throw new Error('SA ' + storeName + ' type ' + api.typeName + ' did not return a fileKey');\n      }\n      FS.debug && console.log('SA', storeName, 'stored', result.fileKey);\n      // Set the fileKey\n      fileObj.copies[storeName].key = result.fileKey;\n\n      // Update the size, as provided by the SA, in case it was changed by stream transformation\n      if (typeof result.size === \"number\") {\n        fileObj.copies[storeName].size = result.size;\n      }\n\n      // Set last updated time, either provided by SA or now\n      fileObj.copies[storeName].updatedAt = result.storedAt || new Date();\n\n      // If the file object copy havent got a createdAt then set this\n      if (typeof fileObj.copies[storeName].createdAt === 'undefined') {\n        fileObj.copies[storeName].createdAt = fileObj.copies[storeName].updatedAt;\n      }\n\n      fileObj._saveChanges(storeName);\n    });\n\n    // Emit events from SA\n    writeStream.once('stored', function(result) {\n      // XXX Because of the way stores inherit from SA, this will emit on every store.\n      // Maybe need to rewrite the way we inherit from SA?\n      var emitted = self.emit('stored', storeName, fileObj);\n      if (FS.debug && !emitted) {\n        console.log(fileObj.name() + ' was successfully stored in the ' + storeName + ' store. You are seeing this informational message because you enabled debugging and you have not defined any listeners for the \"stored\" event on this store.');\n      }\n    });\n\n    writeStream.on('error', function(error) {\n      // XXX We could wrap and clarify error\n      // XXX Because of the way stores inherit from SA, this will emit on every store.\n      // Maybe need to rewrite the way we inherit from SA?\n      var emitted = self.emit('error', storeName, error, fileObj);\n      if (FS.debug && !emitted) {\n        console.log(error);\n      }\n    });\n\n    return writeStream;\n  };\n\n  //internal\n  self._removeAsync = function(fileKey, callback) {\n    // Remove the file from the store\n    api.remove.call(self, fileKey, callback);\n  };\n\n  /**\n   * @method FS.StorageAdapter.prototype.remove\n   * @public\n   * @param {FS.File} fsFile The FS.File instance to be stored.\n   * @param {Function} [callback] If not provided, will block and return true or false\n   *\n   * Attempts to remove a file from the store. Returns true if removed or not\n   * found, or false if the file couldn't be removed.\n   */\n  self.adapter.remove = function(fileObj, callback) {\n    FS.debug && console.log(\"---SA REMOVE\");\n\n    // Get the fileKey\n    var fileKey = (fileObj instanceof FS.File) ? self.adapter.fileKey(fileObj) : fileObj;\n\n    if (callback) {\n      return self._removeAsync(fileKey, FS.Utility.safeCallback(callback));\n    } else {\n      return Meteor._wrapAsync(self._removeAsync)(fileKey);\n    }\n  };\n\n  self.remove = function(fileObj, callback) {\n    // Add deprecation note\n    console.warn('Storage.remove is deprecating, use \"Storage.adapter.remove\"');\n    return self.adapter.remove(fileObj, callback);\n  };\n\n  if (typeof api.init === 'function') {\n    Meteor._wrapAsync(api.init.bind(self))();\n  }\n\n  // This supports optional transformWrite and transformRead\n  self._transform = new FS.Transform({\n    adapter: self.adapter,\n    // Optional transformation functions:\n    transformWrite: options.transformWrite,\n    transformRead: options.transformRead\n  });\n\n};\n\nNpm.require('util').inherits(FS.StorageAdapter, EventEmitter);","var PassThrough = Npm.require('stream').PassThrough;\n\nFS.Transform = function(options) {\n  var self = this;\n\n  options = options || {};\n\n  if (!(self instanceof FS.Transform))\n    throw new Error('FS.Transform must be called with the \"new\" keyword');\n\n  if (!options.adapter)\n    throw new Error('Transform expects option.adapter to be a storage adapter');\n\n  self.storage = options.adapter;\n\n  // Fetch the transformation functions if any\n  self.transformWrite = options.transformWrite;\n  self.transformRead = options.transformRead;\n};\n\n// Allow packages to add scope\nFS.Transform.scope = {\n// Deprecate gm scope:\n  gm: function(source, height, color) {\n    console.warn('Deprecation notice: `this.gm` is deprecating in favour of the general global `gm` scope');\n    if (typeof gm !== 'function')\n      throw new Error('No graphicsmagick package installed, `gm` not found in scope, eg. `cfs-graphicsmagick`');\n    return gm(source, height, color);\n  }\n// EO Deprecate gm scope\n};\n\n// The transformation stream triggers an \"stored\" event when data is stored into\n// the storage adapter\nFS.Transform.prototype.createWriteStream = function(fileObj, options) {\n  var self = this;\n\n  // Get the file key\n  var fileKey = self.storage.fileKey(fileObj);\n\n  // Rig write stream\n  var destinationStream = self.storage.createWriteStreamForFileKey(fileKey, {\n    // Not all SA's can set these options and cfs dont depend on setting these\n    // but its nice if other systems are accessing the SA that some of the data\n    // is also available to those\n    aliases: [fileObj.name()],\n    contentType: fileObj.type(),\n    metadata: fileObj.metadata\n  });\n\n  if (typeof self.transformWrite === 'function') {\n\n    // Rig read stream for gm\n    var sourceStream = new PassThrough();\n\n    // We pass on the special \"stored\" event for those listening\n    destinationStream.on('stored', function(result) {\n      sourceStream.emit('stored', result);\n    });\n\n    // Rig transform\n    try {\n      self.transformWrite.call(FS.Transform.scope, fileObj, sourceStream, destinationStream);\n      // XXX: If the transform function returns a buffer should we stream that?\n    } catch(err) {\n      // We emit an error - should we throw an error?\n      console.warn('FS.Transform.createWriteStream transform function failed, Error: ');\n      throw err;\n    }\n\n    // Return write stream\n    return sourceStream;\n  } else {\n\n    // We dont transform just normal SA interface\n    return destinationStream;\n  }\n\n};\n\nFS.Transform.prototype.createReadStream = function(fileObj, options) {\n  var self = this;\n\n  // XXX: We can check the copy info, but the readstream wil fail no matter what\n  // var fileInfo = fileObj.getCopyInfo(name);\n  // if (!fileInfo) {\n  //   return new Error('File not found on this store \"' + name + '\"');\n  // }\n  // var fileKey = folder + fileInfo.key;\n\n  // Get the file key\n  var fileKey = self.storage.fileKey(fileObj);\n\n  // Rig read stream\n  var sourceStream = self.storage.createReadStreamForFileKey(fileKey, options);\n\n  if (typeof self.transformRead === 'function') {\n    // Rig write stream\n    var destinationStream = new PassThrough();\n\n    // Rig transform\n    try {\n      self.transformRead.call(FS.Transform.scope, fileObj, sourceStream, destinationStream);\n    } catch(err) {\n      //throw new Error(err);\n      // We emit an error - should we throw an error?\n      sourceStream.emit('error', 'FS.Transform.createReadStream transform function failed');\n    }\n\n    // Return write stream\n    return destinationStream;\n\n  }\n\n  // We dont transform just normal SA interface\n  return sourceStream;\n};\n"]}