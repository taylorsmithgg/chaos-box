{"version":3,"sources":["cfs:access-point/access-point-common.js","cfs:access-point/access-point-handlers.js","cfs:access-point/access-point-server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA,yE;AACA,4C;AACA,mC;AACA,8C;AACA,gD;AACA,G;AACA,4C;AACA,uD;AACA,G;AACA,C;;AAEA,kC;AACA,uB;AACA,oG;AACA,C;;AAEA,iB;AACA,wB;;AAEA,uE;AACA,2D;;AAEA,G;AACA,6B;AACA,U;AACA,0F;AACA,uB;AACA,G;AACA,sD;;AAEA,oC;AACA,uC;AACA,kC;AACA,G;AACA,qC;AACA,yC;AACA,G;;AAEA,wB;AACA,uB;;AAEA,2E;AACA,6D;;AAEA,+E;AACA,4E;AACA,gF;AACA,qE;AACA,gB;AACA,G;AACA,E;;AAEA,E;AACA,qB;AACA,G;;AAEA,G;AACA,uD;AACA,U;AACA,4B;AACA,uK;AACA,wU;AACA,sP;AACA,2K;AACA,2H;AACA,6F;AACA,yF;AACA,wK;AACA,E;AACA,6D;AACA,G;AACA,2C;AACA,kB;AACA,0B;AACA,+B;AACA,gB;AACA,e;AACA,oB;AACA,oB;AACA,wB;AACA,uD;AACA,mD;AACA,qE;AACA,2E;;AAEA,+E;AACA,gD;AACA,6B;AACA,G;;AAEA,yB;AACA,qD;AACA,uE;AACA,qC;AACA,4B;AACA,+B;AACA,yC;AACA,qE;AACA,wE;AACA,uB;AACA,oB;AACA,O;AACA,K;;AAEA,yD;AACA,qE;AACA,0D;AACA,gC;AACA,Y;AACA,oB;AACA,K;;AAEA,0E;AACA,uB;AACA,iH;AACA,mC;AACA,wC;AACA,wB;;AAEA,0B;AACA,uD;AACA,U;;AAEA,4E;AACA,6C;AACA,sE;AACA,S;;AAEA,4B;AACA,oD;AACA,gD;AACA,O;AACA,kD;AACA,yE;AACA,iB;AACA,+B;AACA,K;;AAEA,6B;AACA,oB;AACA,2B;AACA,+B;AACA,K;AACA,2B;AACA,6B;AACA,K;AACA,wB;AACA,+F;AACA,6F;AACA,4F;AACA,6F;AACA,yC;AACA,mC;AACA,K;AACA,sD;AACA,6B;AACA,sC;AACA,K;;AAEA,iC;AACA,a;AACA,2B;AACA,uB;AACA,Y;AACA,sB;AACA,K;;AAEA,+C;AACA,qH;AACA,G;;AAEA,E;;;;;;;;;;;;;;;;;;;;;AC3KA,gB;AACA,4B;;AAEA,sB;;AAEA,G;AACA,+B;AACA,U;AACA,0B;AACA,E;AACA,2B;AACA,G;AACA,qD;AACA,kB;AACA,wE;;AAEA,sF;AACA,+F;;AAEA,I;AACA,0B;AACA,yE;AACA,uE;AACA,yE;AACA,iD;AACA,K;AACA,0B;;AAEA,U;AACA,gC;AACA,I;AACA,E;;AAEA,G;AACA,mC;AACA,U;AACA,6B;AACA,E;AACA,qC;AACA,G;AACA,0D;AACA,wB;AACA,6D;AACA,gC;AACA,E;;AAEA,E;AACA,8E;AACA,+E;;AAEA,qC;AACA,G;AACA,S;AACA,O;AACA,U;AACA,Q;AACA,W;AACA,G;AACA,E;AACA,4C;AACA,Y;AACA,sB;AACA,0C;;AAEA,oC;AACA,2C;;AAEA,sD;AACA,2C;AACA,4B;;AAEA,8E;AACA,mD;AACA,4B;AACA,0C;AACA,uC;AACA,qC;;AAEA,gC;AACA,2C;AACA,0D;;AAEA,oG;AACA,4B;;AAEA,2C;;AAEA,sC;AACA,oB;AACA,2B;AACA,uB;AACA,+B;AACA,6B;AACA,yB;AACA,4C;AACA,c;;AAEA,kB;AACA,2E;AACA,W;;AAEA,gB;AACA,2C;AACA,8E;AACA,S;;AAEA,c;AACA,yB;AACA,O;;AAEA,Y;AACA,4E;AACA,K;AACA,U;AACA,wE;AACA,G;;AAEA,U;AACA,a;AACA,sB;AACA,qB;AACA,mB;AACA,kB;AACA,kB;AACA,I;AACA,E;;AAEA,G;AACA,+B;AACA,U;AACA,0B;AACA,E;AACA,2B;AACA,G;AACA,qD;AACA,kB;AACA,6D;AACA,kF;AACA,oH;;AAEA,gC;;AAEA,mE;AACA,sC;AACA,mD;AACA,iD;AACA,G;;AAEA,8B;AACA,uD;;AAEA,iB;AACA,sF;AACA,G;;AAEA,iB;AACA,4C;;AAEA,kB;AACA,wG;AACA,G;;AAEA,kC;AACA,0C;AACA,uC;AACA,U;AACA,oD;AACA,G;;AAEA,4E;AACA,4C;AACA,iD;AACA,qF;AACA,U;AACA,oD;AACA,G;;AAEA,wC;AACA,wD;;AAEA,6D;AACA,0D;AACA,uG;;AAEA,0E;AACA,sB;AACA,+C;AACA,U;AACA,kC;AACA,G;;AAEA,+E;AACA,0G;AACA,yC;AACA,K;;AAEA,oE;AACA,iD;;AAEA,oD;AACA,oE;;AAEA,yE;AACA,8C;;AAEA,0J;;AAEA,oG;;AAEA,wC;AACA,6C;AACA,wC;AACA,gE;AACA,Y;AACA,+D;AACA,K;AACA,K;;AAEA,4C;AACA,E;;AAEA,G;AACA,qC;AACA,U;AACA,sD;AACA,E;AACA,uC;AACA,G;AACA,iE;AACA,kB;AACA,wE;;AAEA,uD;;AAEA,4B;AACA,8B;;AAEA,iB;AACA,sC;;AAEA,6C;AACA,yH;;AAEA,oC;AACA,8F;;AAEA,+D;AACA,iC;;AAEA,kB;AACA,0B;;AAEA,2B;AACA,4B;AACA,E;;AAEA,G;AACA,qC;AACA,U;AACA,kE;AACA,E;AACA,6C;AACA,G;AACA,iE;AACA,kB;AACA,wE;;AAEA,uC;AACA,8B;;AAEA,+E;;AAEA,wE;AACA,+F;;AAEA,kF;;AAEA,kB;AACA,0B;;AAEA,6C;AACA,E;;;;;;;;;;;;;;;;;;;ACzRA,+B;;AAEA,qB;AACA,sC;AACA,gD;AACA,4C;AACA,oC;AACA,mE;AACA,+C;AACA,U;AACA,Y;AACA,gE;AACA,K;AACA,G;AACA,G;;AAEA,G;AACA,mC;AACA,U;AACA,8I;AACA,qJ;AACA,uB;AACA,G;AACA,4E;AACA,wC;AACA,gC;AACA,G;AACA,oB;AACA,2D;AACA,6D;AACA,O;AACA,U;AACA,+B;AACA,G;AACA,E;;AAEA,G;AACA,0B;AACA,U;AACA,oC;AACA,mE;AACA,uB;AACA,E;AACA,8D;AACA,6D;AACA,yD;AACA,G;AACA,4D;AACA,oD;AACA,4D;AACA,gB;AACA,e;AACA,sC;AACA,2B;AACA,wB;AACA,0B;AACA,sB;AACA,uB;AACA,yB;AACA,W;;AAEA,kG;AACA,E;;AAEA,G;AACA,4B;AACA,U;AACA,oC;AACA,uB;AACA,E;AACA,iE;AACA,G;AACA,0D;AACA,4D;AACA,yD;AACA,E;;AAEA,0B;;AAEA,G;AACA,kC;AACA,W;AACA,gC;AACA,E;AACA,wC;AACA,G;AACA,0C;AACA,kB;AACA,sB;AACA,I;AACA,6D;AACA,4E;AACA,4B;AACA,wE;;AAEA,yC;AACA,2C;;AAEA,4B;AACA,mB;;AAEA,uB;AACA,mD;;AAEA,8C;AACA,uE;;AAEA,uC;AACA,U;AACA,2B;AACA,e;AACA,0B;AACA,4B;AACA,2B;AACA,I;AACA,E;;AAEA,E;AACA,wB;AACA,U;AACA,gF;AACA,gH;AACA,E;AACA,E;AACA,mD;AACA,oE;AACA,+D;;AAEA,qB;AACA,mB;AACA,2B;AACA,4B;AACA,uE;AACA,4C;;AAEA,8E;AACA,8E;AACA,M;AACA,2B;AACA,uE;AACA,4C;;AAEA,iD;AACA,0B;AACA,wE;;AAEA,2C;AACA,8B;AACA,sE;AACA,oC;AACA,6D;AACA,c;AACA,uB;AACA,+D;AACA,gB;AACA,oE;AACA,S;AACA,O;AACA,M;AACA,2B;AACA,uE;AACA,4C;;AAEA,iD;AACA,0B;AACA,wE;;AAEA,2C;AACA,8B;AACA,2E;AACA,sC;AACA,2D;AACA,c;AACA,uB;AACA,yD;AACA,gB;AACA,oE;AACA,S;AACA,O;AACA,M;AACA,8B;AACA,uE;AACA,4C;;AAEA,iD;AACA,0B;AACA,wE;;AAEA,2C;AACA,qB;AACA,uD;AACA,c;AACA,kE;AACA,O;AACA,K;AACA,I;;AAEA,wB;;AAEA,sB;AACA,0D;;AAEA,qD;AACA,wC;AACA,2C;AACA,+B;AACA,kD;AACA,wB;AACA,wC;AACA,K;;AAEA,6E;AACA,6B;;AAEA,E;;AAEA,G;AACA,0B;AACA,U;AACA,2G;AACA,E;AACA,G;AACA,yC;AACA,0E;AACA,sC;AACA,kB;AACA,8C;AACA,yB;;AAEA,2C;AACA,8C;AACA,uC;AACA,8C;AACA,mB;AACA,gC;AACA,kC;AACA,mB;AACA,8B;AACA,G;;AAEA,iC;AACA,oB;AACA,6B;AACA,uD;AACA,8E;AACA,mD;AACA,6C;AACA,0B;AACA,0C;AACA,kB;AACA,gD;AACA,O;AACA,O;AACA,gD;AACA,2C;AACA,uB;AACA,gC;AACA,G;AACA,E;;AAEA,0E;AACA,I;AACA,uD;AACA,6C;AACA,wC;AACA,E;AACA,+C;AACA,Q;AACA,4B;AACA,uB;AACA,8B;AACA,oB;AACA,iD;AACA,uC;AACA,kC;AACA,O;AACA,O;AACA,E;AACA,kC;AACA,+D;AACA,oB;;AAEA,iB;AACA,qD;AACA,2C;AACA,sC;AACA,K;AACA,E;;AAEA,oC;AACA,gD;AACA,kB;;AAEA,8C;AACA,sC;;AAEA,kD;;AAEA,mD;;AAEA,yD;AACA,wB;AACA,kD;;AAEA,kB;AACA,O;AACA,0C;AACA,gB;AACA,+C;AACA,G;;AAEA,0C;AACA,wC;AACA,mC;AACA,+C;AACA,G;;AAEA,yE;AACA,uC;AACA,2B;AACA,yB;AACA,uC;AACA,mG;AACA,mD;AACA,K;AACA,G;;AAEA,oE;AACA,mC;AACA,U;AACA,uF;AACA,sD;AACA,K;AACA,K;;AAEA,gC;AACA,0B;AACA,E;;AAEA,a;AACA,uB;AACA,yB;AACA,mC;AACA,K;AACA,G;AACA,G;;AAEA,4B;AACA,0B;AACA,oB;AACA,E;;AAEA,kC;AACA,4B;AACA,c;AACA,G","file":"/packages/cfs_access-point.js","sourcesContent":["rootUrlPathPrefix = __meteor_runtime_config__.ROOT_URL_PATH_PREFIX || \"\";\n// Adjust the rootUrlPathPrefix if necessary\nif (rootUrlPathPrefix.length > 0) {\n  if (rootUrlPathPrefix.slice(0, 1) !== '/') {\n    rootUrlPathPrefix = '/' + rootUrlPathPrefix;\n  }\n  if (rootUrlPathPrefix.slice(-1) === '/') {\n    rootUrlPathPrefix = rootUrlPathPrefix.slice(0, -1);\n  }\n}\n\n// prepend ROOT_URL when isCordova\nif (Meteor.isCordova) {\n  rootUrlPathPrefix = Meteor.absoluteUrl(rootUrlPathPrefix.replace(/^\\/+/, '')).replace(/\\/+$/, '');\n}\n\nbaseUrl = '/cfs';\nFS.HTTP = FS.HTTP || {};\n\n// Note the upload URL so that client uploader packages know what it is\nFS.HTTP.uploadUrl = rootUrlPathPrefix + baseUrl + '/files';\n\n/**\n * @method FS.HTTP.setBaseUrl\n * @public\n * @param {String} newBaseUrl - Change the base URL for the HTTP GET and DELETE endpoints.\n * @returns {undefined}\n */\nFS.HTTP.setBaseUrl = function setBaseUrl(newBaseUrl) {\n\n  // Adjust the baseUrl if necessary\n  if (newBaseUrl.slice(0, 1) !== '/') {\n    newBaseUrl = '/' + newBaseUrl;\n  }\n  if (newBaseUrl.slice(-1) === '/') {\n    newBaseUrl = newBaseUrl.slice(0, -1);\n  }\n\n  // Update the base URL\n  baseUrl = newBaseUrl;\n\n  // Change the upload URL so that client uploader packages know what it is\n  FS.HTTP.uploadUrl = rootUrlPathPrefix + baseUrl + '/files';\n\n  // Remount URLs with the new baseUrl, unmounting the old, on the server only.\n  // If existingMountPoints is empty, then we haven't run the server startup\n  // code yet, so this new URL will be used at that point for the initial mount.\n  if (Meteor.isServer && !FS.Utility.isEmpty(_existingMountPoints)) {\n    mountUrls();\n  }\n};\n\n/*\n * FS.File extensions\n */\n\n/**\n * @method FS.File.prototype.url Construct the file url\n * @public\n * @param {Object} [options]\n * @param {String} [options.store] Name of the store to get from. If not defined, the first store defined in `options.stores` for the collection on the client is used.\n * @param {Boolean} [options.auth=null] Add authentication token to the URL query string? By default, a token for the current logged in user is added on the client. Set this to `false` to omit the token. Set this to a string to provide your own token. Set this to a number to specify an expiration time for the token in seconds.\n * @param {Boolean} [options.download=false] Should headers be set to force a download? Typically this means that clicking the link with this URL will download the file to the user's Downloads folder instead of displaying the file in the browser.\n * @param {Boolean} [options.brokenIsFine=false] Return the URL even if we know it's currently a broken link because the file hasn't been saved in the requested store yet.\n * @param {Boolean} [options.metadata=false] Return the URL for the file metadata access point rather than the file itself.\n * @param {String} [options.uploading=null] A URL to return while the file is being uploaded.\n * @param {String} [options.storing=null] A URL to return while the file is being stored.\n * @param {String} [options.filename=null] Override the filename that should appear at the end of the URL. By default it is the name of the file in the requested store.\n *\n * Returns the HTTP URL for getting the file or its metadata.\n */\nFS.File.prototype.url = function(options) {\n  var self = this;\n  options = options || {};\n  options = FS.Utility.extend({\n    store: null,\n    auth: null,\n    download: false,\n    metadata: false,\n    brokenIsFine: false,\n    uploading: null, // return this URL while uploading\n    storing: null, // return this URL while storing\n    filename: null // override the filename that is shown to the user\n  }, options.hash || options); // check for \"hash\" prop if called as helper\n\n  // Primarily useful for displaying a temporary image while uploading an image\n  if (options.uploading && !self.isUploaded()) {\n    return options.uploading;\n  }\n\n  if (self.isMounted()) {\n    // See if we've stored in the requested store yet\n    var storeName = options.store || self.collection.primaryStore.name;\n    if (!self.hasStored(storeName)) {\n      if (options.storing) {\n        return options.storing;\n      } else if (!options.brokenIsFine) {\n        // We want to return null if we know the URL will be a broken\n        // link because then we can avoid rendering broken links, broken\n        // images, etc.\n        return null;\n      }\n    }\n\n    // Add filename to end of URL if we can determine one\n    var filename = options.filename || self.name({store: storeName});\n    if (typeof filename === \"string\" && filename.length) {\n      filename = '/' + filename;\n    } else {\n      filename = '';\n    }\n\n    // TODO: Could we somehow figure out if the collection requires login?\n    var authToken = '';\n    if (Meteor.isClient && typeof Accounts !== \"undefined\" && typeof Accounts._storedLoginToken === \"function\") {\n      if (options.auth !== false) {\n        // Add reactive deps on the user\n        Meteor.userId();\n\n        var authObject = {\n          authToken: Accounts._storedLoginToken() || ''\n        };\n\n        // If it's a number, we use that as the expiration time (in seconds)\n        if (options.auth === +options.auth) {\n          authObject.expiration = FS.HTTP.now() + options.auth * 1000;\n        }\n\n        // Set the authToken\n        var authString = JSON.stringify(authObject);\n        authToken = FS.Utility.btoa(authString);\n      }\n    } else if (typeof options.auth === \"string\") {\n      // If the user supplies auth token the user will be responsible for\n      // updating\n      authToken = options.auth;\n    }\n\n    // Construct query string\n    var params = {};\n    if (authToken !== '') {\n      params.token = authToken;\n    }\n    if (options.download) {\n      params.download = true;\n    }\n    if (options.store) {\n      // We use options.store here instead of storeName because we want to omit the queryString\n      // whenever possible, allowing users to have \"clean\" URLs if they want. The server will\n      // assume the first store defined on the server, which means that we are assuming that\n      // the first on the client is also the first on the server. If that's not the case, the\n      // store option should be supplied.\n      params.store = options.store;\n    }\n    var queryString = FS.Utility.encodeParams(params);\n    if (queryString.length) {\n      queryString = '?' + queryString;\n    }\n\n    // Determine which URL to use\n    var area;\n    if (options.metadata) {\n      area = '/record';\n    } else {\n      area = '/files';\n    }\n\n    // Construct and return the http method url\n    return rootUrlPathPrefix + baseUrl + area + '/' + self.collection.name + '/' + self._id + filename + queryString;\n  }\n\n};\n\n\n","getHeaders = [];\ngetHeadersByCollection = {};\n\nFS.HTTP.Handlers = {};\n\n/**\n * @method FS.HTTP.Handlers.Del\n * @public\n * @returns {any} response\n *\n * HTTP DEL request handler\n */\nFS.HTTP.Handlers.Del = function httpDelHandler(ref) {\n  var self = this;\n  var opts = FS.Utility.extend({}, self.query || {}, self.params || {});\n\n  // If DELETE request, validate with 'remove' allow/deny, delete the file, and return\n  FS.Utility.validateAction(ref.collection.files._validators['remove'], ref.file, self.userId);\n\n  /*\n   * From the DELETE spec:\n   * A successful response SHOULD be 200 (OK) if the response includes an\n   * entity describing the status, 202 (Accepted) if the action has not\n   * yet been enacted, or 204 (No Content) if the action has been enacted\n   * but the response does not include an entity.\n   */\n  self.setStatusCode(200);\n\n  return {\n    deleted: !!ref.file.remove()\n  };\n};\n\n/**\n * @method FS.HTTP.Handlers.GetList\n * @public\n * @returns {Object} response\n *\n * HTTP GET file list request handler\n */\nFS.HTTP.Handlers.GetList = function httpGetListHandler() {\n  // Not Yet Implemented\n  // Need to check publications and return file list based on\n  // what user is allowed to see\n};\n\n/*\n  requestRange will parse the range set in request header - if not possible it\n  will throw fitting errors and autofill range for both partial and full ranges\n\n  throws error or returns the object:\n  {\n    start\n    end\n    length\n    unit\n    partial\n  }\n*/\nvar requestRange = function(req, fileSize) {\n  if (req) {\n    if (req.headers) {\n      var rangeString = req.headers.range;\n\n      // Make sure range is a string\n      if (rangeString === ''+rangeString) {\n\n        // range will be in the format \"bytes=0-32767\"\n        var parts = rangeString.split('=');\n        var unit = parts[0];\n\n        // Make sure parts consists of two strings and range is of type \"byte\"\n        if (parts.length == 2 && unit == 'bytes') {\n          // Parse the range\n          var range = parts[1].split('-');\n          var start = Number(range[0]);\n          var end = Number(range[1]);\n\n          // Fix invalid ranges?\n          if (range[0] != start) start = 0;\n          if (range[1] != end || !end) end = fileSize - 1;\n\n          // Make sure range consists of a start and end point of numbers and start is less than end\n          if (start < end) {\n\n            var partSize = start + end + 1;\n\n            // Return the parsed range\n            return {\n              start: start,\n              end: end,\n              length: partSize,\n              size: fileSize,\n              unit: unit,\n              partial: (partSize < fileSize)\n            };\n\n          } else {\n            throw new Meteor.Error(416, \"Requested Range Not Satisfiable\");\n          }\n\n        } else {\n          // The first part should be bytes\n          throw new Meteor.Error(416, \"Requested Range Unit Not Satisfiable\");\n        }\n\n      } else {\n        // No range found\n      }\n\n    } else {\n      // throw new Error('No request headers set for _parseRange function');\n    }\n  } else {\n    throw new Error('No request object passed to _parseRange function');\n  }\n\n  return {\n    start: 0,\n    end: fileSize - 1,\n    length: fileSize,\n    size: fileSize,\n    unit: 'bytes',\n    partial: false\n  };\n};\n\n/**\n * @method FS.HTTP.Handlers.Get\n * @public\n * @returns {any} response\n *\n * HTTP GET request handler\n */\nFS.HTTP.Handlers.Get = function httpGetHandler(ref) {\n  var self = this;\n  // Once we have the file, we can test allow/deny validators\n  // XXX: pass on the \"share\" query eg. ?share=342hkjh23ggj for shared url access?\n  FS.Utility.validateAction(ref.collection._validators['download'], ref.file, self.userId /*, self.query.shareId*/);\n\n  var storeName = ref.storeName;\n\n  // If no storeName was specified, use the first defined storeName\n  if (typeof storeName !== \"string\") {\n    // No store handed, we default to primary store\n    storeName = ref.collection.primaryStore.name;\n  }\n\n  // Get the storage reference\n  var storage = ref.collection.storesLookup[storeName];\n\n  if (!storage) {\n    throw new Meteor.Error(404, \"Not Found\", 'There is no store \"' + storeName + '\"');\n  }\n\n  // Get the file\n  var copyInfo = ref.file.copies[storeName];\n\n  if (!copyInfo) {\n    throw new Meteor.Error(404, \"Not Found\", 'This file was not stored in the ' + storeName + ' store');\n  }\n\n  // Set the content type for file\n  if (typeof copyInfo.type === \"string\") {\n    self.setContentType(copyInfo.type);\n  } else {\n    self.setContentType('application/octet-stream');\n  }\n\n  // Add 'Content-Disposition' header if requested a download/attachment URL\n  if (typeof ref.download !== \"undefined\") {\n    var filename = ref.filename || copyInfo.name;\n    self.addHeader('Content-Disposition', 'attachment; filename=\"' + filename + '\"');\n  } else {\n    self.addHeader('Content-Disposition', 'inline');\n  }\n\n  // Get the contents range from request\n  var range = requestRange(self.request, copyInfo.size);\n\n  // Some browsers cope better if the content-range header is\n  // still included even for the full file being returned.\n  self.addHeader('Content-Range', range.unit + ' ' + range.start + '-' + range.end + '/' + range.size);\n\n  // If a chunk/range was requested instead of the whole file, serve that'\n  if (range.partial) {\n    self.setStatusCode(206, 'Partial Content');\n  } else {\n    self.setStatusCode(200, 'OK');\n  }\n\n  // Add any other global custom headers and collection-specific custom headers\n  FS.Utility.each(getHeaders.concat(getHeadersByCollection[ref.collection.name] || []), function(header) {\n    self.addHeader(header[0], header[1]);\n  });\n\n  // Inform clients about length (or chunk length in case of ranges)\n  self.addHeader('Content-Length', range.length);\n\n  // Last modified header (updatedAt from file info)\n  self.addHeader('Last-Modified', copyInfo.updatedAt.toUTCString());\n\n  // Inform clients that we accept ranges for resumable chunked downloads\n  self.addHeader('Accept-Ranges', range.unit);\n\n  if (FS.debug) console.log('Read file \"' + (ref.filename || copyInfo.name) + '\" ' + range.unit + ' ' + range.start + '-' + range.end + '/' + range.size);\n\n  var readStream = storage.adapter.createReadStream(ref.file, {start: range.start, end: range.end});\n\n  readStream.on('error', function(err) {\n    // Send proper error message on get error\n    if (err.message && err.statusCode) {\n      self.Error(new Meteor.Error(err.statusCode, err.message));\n    } else {\n      self.Error(new Meteor.Error(503, 'Service unavailable'));\n    }\n  });\n\n  readStream.pipe(self.createWriteStream());\n};\n\n/**\n * @method FS.HTTP.Handlers.PutInsert\n * @public\n * @returns {Object} response object with _id property\n *\n * HTTP PUT file insert request handler\n */\nFS.HTTP.Handlers.PutInsert = function httpPutInsertHandler(ref) {\n  var self = this;\n  var opts = FS.Utility.extend({}, self.query || {}, self.params || {});\n\n  FS.debug && console.log(\"HTTP PUT (insert) handler\");\n\n  // Create the nice FS.File\n  var fileObj = new FS.File();\n\n  // Set its name\n  fileObj.name(opts.filename || null);\n\n  // Attach the readstream as the file's data\n  fileObj.attachData(self.createReadStream(), {type: self.requestHeaders['content-type'] || 'application/octet-stream'});\n\n  // Validate with insert allow/deny\n  FS.Utility.validateAction(ref.collection.files._validators['insert'], fileObj, self.userId);\n\n  // Insert file into collection, triggering readStream storage\n  ref.collection.insert(fileObj);\n\n  // Send response\n  self.setStatusCode(200);\n\n  // Return the new file id\n  return {_id: fileObj._id};\n};\n\n/**\n * @method FS.HTTP.Handlers.PutUpdate\n * @public\n * @returns {Object} response object with _id and chunk properties\n *\n * HTTP PUT file update chunk request handler\n */\nFS.HTTP.Handlers.PutUpdate = function httpPutUpdateHandler(ref) {\n  var self = this;\n  var opts = FS.Utility.extend({}, self.query || {}, self.params || {});\n\n  var chunk = parseInt(opts.chunk, 10);\n  if (isNaN(chunk)) chunk = 0;\n\n  FS.debug && console.log(\"HTTP PUT (update) handler received chunk: \", chunk);\n\n  // Validate with insert allow/deny; also mounts and retrieves the file\n  FS.Utility.validateAction(ref.collection.files._validators['insert'], ref.file, self.userId);\n\n  self.createReadStream().pipe( FS.TempStore.createWriteStream(ref.file, chunk) );\n\n  // Send response\n  self.setStatusCode(200);\n\n  return { _id: ref.file._id, chunk: chunk };\n};\n","var path = Npm.require(\"path\");\n\nHTTP.publishFormats({\n  fileRecordFormat: function (input) {\n    // Set the method scope content type to json\n    this.setContentType('application/json');\n    if (FS.Utility.isArray(input)) {\n      return EJSON.stringify(FS.Utility.map(input, function (obj) {\n        return FS.Utility.cloneFileRecord(obj);\n      }));\n    } else {\n      return EJSON.stringify(FS.Utility.cloneFileRecord(input));\n    }\n  }\n});\n\n/**\n * @method FS.HTTP.setHeadersForGet\n * @public\n * @param {Array} headers - List of headers, where each is a two-item array in which item 1 is the header name and item 2 is the header value.\n * @param {Array|String} [collections] - Which collections the headers should be added for. Omit this argument to add the header for all collections.\n * @returns {undefined}\n */\nFS.HTTP.setHeadersForGet = function setHeadersForGet(headers, collections) {\n  if (typeof collections === \"string\") {\n    collections = [collections];\n  }\n  if (collections) {\n    FS.Utility.each(collections, function(collectionName) {\n      getHeadersByCollection[collectionName] = headers || [];\n    });\n  } else {\n    getHeaders = headers || [];\n  }\n};\n\n/**\n * @method FS.HTTP.publish\n * @public\n * @param {FS.Collection} collection\n * @param {Function} func - Publish function that returns a cursor.\n * @returns {undefined}\n *\n * Publishes all documents returned by the cursor at a GET URL\n * with the format baseUrl/record/collectionName. The publish\n * function `this` is similar to normal `Meteor.publish`.\n */\nFS.HTTP.publish = function fsHttpPublish(collection, func) {\n  var name = baseUrl + '/record/' + collection.name;\n  // Mount collection listing URL using http-publish package\n  HTTP.publish({\n    name: name,\n    defaultFormat: 'fileRecordFormat',\n    collection: collection,\n    collectionGet: true,\n    collectionPost: false,\n    documentGet: true,\n    documentPut: false,\n    documentDelete: false\n  }, func);\n\n  FS.debug && console.log(\"Registered HTTP method GET URLs:\\n\\n\" + name + '\\n' + name + '/:id\\n');\n};\n\n/**\n * @method FS.HTTP.unpublish\n * @public\n * @param {FS.Collection} collection\n * @returns {undefined}\n *\n * Unpublishes a restpoint created by a call to `FS.HTTP.publish`\n */\nFS.HTTP.unpublish = function fsHttpUnpublish(collection) {\n  // Mount collection listing URL using http-publish package\n  HTTP.unpublish(baseUrl + '/record/' + collection.name);\n};\n\n_existingMountPoints = {};\n\n/**\n * @method defaultSelectorFunction\n * @private\n * @returns { collection, file }\n *\n * This is the default selector function\n */\nvar defaultSelectorFunction = function() {\n  var self = this;\n  // Selector function\n  //\n  // This function will have to return the collection and the\n  // file. If file not found undefined is returned - if null is returned the\n  // search was not possible\n  var opts = FS.Utility.extend({}, self.query || {}, self.params || {});\n\n  // Get the collection name from the url\n  var collectionName = opts.collectionName;\n\n  // Get the id from the url\n  var id = opts.id;\n\n  // Get the collection\n  var collection = FS._collections[collectionName];\n\n  // Get the file if possible else return null\n  var file = (id && collection)? collection.findOne({ _id: id }): null;\n\n  // Return the collection and the file\n  return {\n    collection: collection,\n    file: file,\n    storeName: opts.store,\n    download: opts.download,\n    filename: opts.filename\n  };\n};\n\n/*\n * @method FS.HTTP.mount\n * @public\n * @param {array of string} mountPoints mount points to map rest functinality on\n * @param {function} selector_f [selector] function returns `{ collection, file }` for mount points to work with\n *\n*/\nFS.HTTP.mount = function(mountPoints, selector_f) {\n  // We take mount points as an array and we get a selector function\n  var selectorFunction = selector_f || defaultSelectorFunction;\n\n  var accessPoint = {\n    'stream': true,\n    'auth': expirationAuth,\n    'post': function(data) {\n      // Use the selector for finding the collection and file reference\n      var ref = selectorFunction.call(this);\n\n      // We dont support post - this would be normal insert eg. of filerecord?\n      throw new Meteor.Error(501, \"Not implemented\", \"Post is not supported\");\n    },\n    'put': function(data) {\n      // Use the selector for finding the collection and file reference\n      var ref = selectorFunction.call(this);\n\n      // Make sure we have a collection reference\n      if (!ref.collection)\n        throw new Meteor.Error(404, \"Not Found\", \"No collection found\");\n\n      // Make sure we have a file reference\n      if (ref.file === null) {\n        // No id supplied so we will create a new FS.File instance and\n        // insert the supplied data.\n        return FS.HTTP.Handlers.PutInsert.apply(this, [ref]);\n      } else {\n        if (ref.file) {\n          return FS.HTTP.Handlers.PutUpdate.apply(this, [ref]);\n        } else {\n          throw new Meteor.Error(404, \"Not Found\", 'No file found');\n        }\n      }\n    },\n    'get': function(data) {\n      // Use the selector for finding the collection and file reference\n      var ref = selectorFunction.call(this);\n\n      // Make sure we have a collection reference\n      if (!ref.collection)\n        throw new Meteor.Error(404, \"Not Found\", \"No collection found\");\n\n      // Make sure we have a file reference\n      if (ref.file === null) {\n        // No id supplied so we will return the published list of files ala\n        // http.publish in json format\n        return FS.HTTP.Handlers.GetList.apply(this, [ref]);\n      } else {\n        if (ref.file) {\n          return FS.HTTP.Handlers.Get.apply(this, [ref]);\n        } else {\n          throw new Meteor.Error(404, \"Not Found\", 'No file found');\n        }\n      }\n    },\n    'delete': function(data) {\n      // Use the selector for finding the collection and file reference\n      var ref = selectorFunction.call(this);\n\n      // Make sure we have a collection reference\n      if (!ref.collection)\n        throw new Meteor.Error(404, \"Not Found\", \"No collection found\");\n\n      // Make sure we have a file reference\n      if (ref.file) {\n        return FS.HTTP.Handlers.Del.apply(this, [ref]);\n      } else {\n        throw new Meteor.Error(404, \"Not Found\", 'No file found');\n      }\n    }\n  };\n\n  var accessPoints = {};\n\n  // Add debug message\n  FS.debug && console.log('Registered HTTP method URLs:');\n\n  FS.Utility.each(mountPoints, function(mountPoint) {\n    // Couple mountpoint and accesspoint\n    accessPoints[mountPoint] = accessPoint;\n    // Remember our mountpoints\n    _existingMountPoints[mountPoint] = mountPoint;\n    // Add debug message\n    FS.debug && console.log(mountPoint);\n  });\n\n  // XXX: HTTP:methods should unmount existing mounts in case of overwriting?\n  HTTP.methods(accessPoints);\n\n};\n\n/**\n * @method FS.HTTP.unmount\n * @public\n * @param {string | array of string} [mountPoints] Optional, if not specified all mountpoints are unmounted\n *\n */\nFS.HTTP.unmount = function(mountPoints) {\n  // The mountPoints is optional, can be string or array if undefined then\n  // _existingMountPoints will be used\n  var unmountList;\n  // Container for the mount points to unmount\n  var unmountPoints = {};\n\n  if (typeof mountPoints === 'undefined') {\n    // Use existing mount points - unmount all\n    unmountList = _existingMountPoints;\n  } else if (mountPoints === ''+mountPoints) {\n    // Got a string\n    unmountList = [mountPoints];\n  } else if (mountPoints.length) {\n    // Got an array\n    unmountList = mountPoints;\n  }\n\n  // If we have a list to unmount\n  if (unmountList) {\n    // Iterate over each item\n    FS.Utility.each(unmountList, function(mountPoint) {\n      // Check _existingMountPoints to make sure the mount point exists in our\n      // context / was created by the FS.HTTP.mount\n      if (_existingMountPoints[mountPoint]) {\n        // Mark as unmount\n        unmountPoints[mountPoint] = false;\n        // Release\n        delete _existingMountPoints[mountPoint];\n      }\n    });\n    FS.debug && console.log('FS.HTTP.unmount:');\n    FS.debug && console.log(unmountPoints);\n    // Complete unmount\n    HTTP.methods(unmountPoints);\n  }\n};\n\n// ### FS.Collection maps on HTTP pr. default on the following restpoints:\n// *\n//    baseUrl + '/files/:collectionName/:id/:filename',\n//    baseUrl + '/files/:collectionName/:id',\n//    baseUrl + '/files/:collectionName'\n//\n// Change/ replace the existing mount point by:\n// ```js\n//   // unmount all existing\n//   FS.HTTP.unmount();\n//   // Create new mount point\n//   FS.HTTP.mount([\n//    '/cfs/files/:collectionName/:id/:filename',\n//    '/cfs/files/:collectionName/:id',\n//    '/cfs/files/:collectionName'\n//  ]);\n//  ```\n//\nmountUrls = function mountUrls() {\n  // We unmount first in case we are calling this a second time\n  FS.HTTP.unmount();\n\n  FS.HTTP.mount([\n    baseUrl + '/files/:collectionName/:id/:filename',\n    baseUrl + '/files/:collectionName/:id',\n    baseUrl + '/files/:collectionName'\n  ]);\n};\n\n// Returns the userId from URL token\nvar expirationAuth = function expirationAuth() {\n  var self = this;\n\n  // Read the token from '/hello?token=base64'\n  var encodedToken = self.query.token;\n\n  FS.debug && console.log(\"token: \"+encodedToken);\n\n  if (!encodedToken || !Meteor.users) return false;\n\n  // Check the userToken before adding it to the db query\n  // Set the this.userId\n  var tokenString = FS.Utility.atob(encodedToken);\n\n  var tokenObject;\n  try {\n    tokenObject = JSON.parse(tokenString);\n  } catch(err) {\n    throw new Meteor.Error(400, 'Bad Request');\n  }\n\n  // XXX: Do some check here of the object\n  var userToken = tokenObject.authToken;\n  if (userToken !== ''+userToken) {\n    throw new Meteor.Error(400, 'Bad Request');\n  }\n\n  // If we have an expiration token we should check that it's still valid\n  if (tokenObject.expiration != null) {\n    // check if its too old\n    var now = Date.now();\n    if (tokenObject.expiration < now) {\n      FS.debug && console.log('Expired token: ' + tokenObject.expiration + ' is less than ' + now);\n      throw new Meteor.Error(500, 'Expired token');\n    }\n  }\n\n  // We are not on a secure line - so we have to look up the user...\n  var user = Meteor.users.findOne({\n    $or: [\n      {'services.resume.loginTokens.hashedToken': Accounts._hashLoginToken(userToken)},\n      {'services.resume.loginTokens.token': userToken}\n    ]\n  });\n\n  // Set the userId in the scope\n  return user && user._id;\n};\n\nHTTP.methods(\n  {'/cfs/servertime': {\n    get: function(data) {\n      return Date.now().toString();\n    }\n  }\n});\n\n// Unify client / server api\nFS.HTTP.now = function() {\n  return Date.now();\n};\n\n// Start up the basic mount points\nMeteor.startup(function () {\n  mountUrls();\n});\n"]}