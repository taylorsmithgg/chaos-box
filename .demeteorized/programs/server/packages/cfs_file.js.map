{"version":3,"sources":["cfs:file/fsFile-common.js","cfs:file/fsFile-server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA,G;AACA,kB;AACA,qB;AACA,U;AACA,e;AACA,0H;AACA,G;AACA,6C;AACA,kB;;AAEA,iD;;AAEA,qD;AACA,+C;AACA,2E;AACA,mB;AACA,yB;AACA,G;AACA,E;;AAEA,6B;AACA,uC;;AAEA,G;AACA,uC;AACA,U;AACA,6G;AACA,oC;AACA,yE;AACA,yH;AACA,kI;AACA,2H;AACA,4C;AACA,E;AACA,G;AACA,mF;AACA,kB;;AAEA,mD;AACA,uB;AACA,iB;AACA,G;AACA,0B;;AAEA,c;AACA,kF;AACA,G;;AAEA,c;;AAEA,mE;AACA,S;AACA,4D;AACA,yB;AACA,0C;AACA,yB;AACA,uB;AACA,G;AACA,S;AACA,iE;AACA,+B;AACA,yB;AACA,uB;AACA,G;AACA,mE;AACA,uC;AACA,yG;AACA,6C;AACA,uB;AACA,0B;AACA,K;;AAEA,oB;AACA,4B;AACA,qG;AACA,O;AACA,iE;AACA,kD;AACA,2B;AACA,Y;AACA,8E;AACA,4D;AACA,oB;AACA,0B;AACA,gB;AACA,sD;AACA,+B;AACA,S;AACA,S;AACA,K;AACA,G;AACA,oB;AACA,Q;AACA,0B;AACA,G;;AAEA,iB;AACA,0B;AACA,iD;;AAEA,gD;AACA,gC;;AAEA,iD;AACA,6E;AACA,yE;AACA,wF;AACA,uB;AACA,qB;AACA,+C;AACA,sB;AACA,wC;AACA,kB;AACA,4B;AACA,sB;AACA,W;AACA,W;AACA,c;AACA,oC;AACA,kB;AACA,O;AACA,Y;AACA,gB;AACA,K;AACA,G;;AAEA,sB;AACA,6D;AACA,mD;AACA,sB;AACA,0E;AACA,uD;AACA,kF;AACA,kD;AACA,S;AACA,O;AACA,2B;AACA,8C;AACA,gD;AACA,O;AACA,K;;AAEA,2B;AACA,G;;AAEA,+B;AACA,E;;AAEA,G;AACA,2C;AACA,U;AACA,yD;AACA,G;AACA,+C;AACA,kB;AACA,yC;AACA,uB;;AAEA,kC;AACA,wB;AACA,e;AACA,G;AACA,iD;AACA,Q;AACA,2E;AACA,G;AACA,E;;AAEA,G;AACA,6C;AACA,U;AACA,oE;AACA,E;AACA,6E;AACA,+E;AACA,8E;AACA,iB;AACA,G;AACA,iD;AACA,kB;AACA,gD;AACA,E;;AAEA,G;AACA,0C;AACA,U;AACA,mF;AACA,G;AACA,8C;AACA,iC;AACA,kB;;AAEA,gD;AACA,wB;AACA,2B;AACA,G;;AAEA,+E;AACA,oB;AACA,6B;AACA,4E;AACA,oC;AACA,W;AACA,G;;AAEA,oC;AACA,yD;;AAEA,2E;AACA,E;;AAEA,G;AACA,sC;AACA,U;AACA,mF;AACA,G;AACA,8D;;AAEA,G;AACA,iE;AACA,U;AACA,mC;AACA,G;AACA,8C;AACA,kB;AACA,0E;AACA,gB;AACA,gC;AACA,gB;AACA,G;AACA,6C;AACA,yB;AACA,2D;;AAEA,+C;AACA,0E;AACA,wC;AACA,sB;AACA,U;AACA,gF;AACA,+B;AACA,c;AACA,G;AACA,E;;AAEA,G;AACA,mC;AACA,U;AACA,6B;AACA,4B;AACA,+B;AACA,E;AACA,0B;AACA,G;AACA,kE;AACA,kB;;AAEA,iE;;AAEA,2C;AACA,mD;AACA,uB;AACA,iB;AACA,G;AACA,oD;;AAEA,0B;AACA,yF;AACA,W;AACA,G;;AAEA,yC;AACA,gG;AACA,gE;AACA,iE;AACA,qC;AACA,2B;AACA,oB;AACA,yB;AACA,K;AACA,E;;AAEA,G;AACA,yC;AACA,W;AACA,6H;AACA,E;AACA,4E;AACA,G;AACA,iD;AACA,kB;;AAEA,0B;AACA,W;AACA,G;;AAEA,kE;;AAEA,uB;AACA,6B;AACA,sC;AACA,wC;AACA,iC;AACA,e;AACA,wC;AACA,K;AACA,U;AACA,sC;AACA,kC;AACA,G;;AAEA,mB;AACA,E;;AAEA,G;AACA,mC;AACA,U;AACA,+B;AACA,0B;AACA,E;AACA,iD;AACA,G;AACA,+C;AACA,kB;;AAEA,iD;;AAEA,oD;;AAEA,0B;AACA,yF;AACA,W;AACA,G;;AAEA,2E;AACA,e;AACA,sB;AACA,6B;AACA,iC;AACA,K;AACA,uB;AACA,K;AACA,E;;AAEA,G;AACA,mC;AACA,0C;AACA,+C;AACA,gC;AACA,E;AACA,8D;AACA,E;AACA,8B;AACA,G;;AAEA,G;AACA,8E;AACA,U;AACA,gE;AACA,4B;AACA,mF;AACA,qF;AACA,G;AACA,oD;AACA,kB;AACA,iC;AACA,E;;AAEA,2D;AACA,W;AACA,iD;AACA,2C;AACA,U;AACA,yB;AACA,G;AACA,iC;AACA,2C;AACA,G;AACA,e;AACA,C;;AAEA,G;AACA,yD;AACA,U;AACA,4B;AACA,gE;AACA,E;AACA,4E;AACA,2E;AACA,2E;AACA,yC;AACA,G;AACA,+C;AACA,iE;AACA,E;;AAEA,G;AACA,wD;AACA,U;AACA,4B;AACA,gE;AACA,E;AACA,2E;AACA,2E;AACA,2E;AACA,yC;AACA,G;AACA,+C;AACA,iE;AACA,E;;AAEA,G;AACA,yD;AACA,U;AACA,4B;AACA,gE;AACA,E;AACA,4E;AACA,2E;AACA,2E;AACA,yC;AACA,G;AACA,+C;AACA,iE;AACA,E;;AAEA,G;AACA,0C;AACA,U;AACA,2B;AACA,8G;AACA,uF;AACA,8F;AACA,E;AACA,mF;AACA,wE;AACA,G;AACA,yE;AACA,kB;;AAEA,oC;AACA,0F;;AAEA,0B;AACA,oC;;AAEA,qC;AACA,gE;AACA,E;;AAEA,G;AACA,yE;AACA,U;AACA,qF;AACA,G;AACA,2C;AACA,kB;;AAEA,6C;AACA,uB;;AAEA,2B;AACA,E;;AAEA,G;AACA,sC;AACA,U;AACA,8C;AACA,4F;AACA,0E;AACA,E;AACA,0E;AACA,yE;AACA,0E;AACA,4E;AACA,oC;AACA,G;AACA,+D;AACA,kB;AACA,6C;AACA,uB;AACA,yC;AACA,wC;AACA,wB;AACA,G;AACA,sC;AACA,gF;AACA,2B;AACA,mF;AACA,G;AACA,e;AACA,E;;AAEA,0B;AACA,wD;;AAEA,G;AACA,wC;AACA,U;AACA,kE;AACA,0E;AACA,6G;AACA,G;AACA,qD;AACA,kB;AACA,6C;AACA,uB;AACA,yD;AACA,E;;AAEA,G;AACA,qC;AACA,W;AACA,4G;AACA,4B;AACA,2G;AACA,yG;AACA,G;AACA,2D;AACA,kB;AACA,0B;;AAEA,sC;AACA,+C;AACA,yB;AACA,G;;AAEA,kB;AACA,yD;AACA,U;AACA,+B;AACA,G;AACA,E;;AAEA,G;AACA,qC;AACA,W;AACA,uH;AACA,6C;AACA,iD;AACA,+G;AACA,uB;AACA,G;AACA,yE;AACA,kB;AACA,sC;AACA,oC;AACA,0D;AACA,6C;AACA,yC;AACA,U;AACA,wC;AACA,oC;AACA,2C;AACA,G;AACA,E;;AAEA,G;AACA,iC;AACA,U;AACA,kJ;AACA,4B;AACA,kK;AACA,yI;AACA,8F;AACA,kG;AACA,G;AACA,mD;AACA,kB;;AAEA,oG;AACA,U;AACA,0B;AACA,gE;AACA,sD;AACA,U;AACA,U;AACA,4B;AACA,gH;AACA,G;AACA,E;;AAEA,G;AACA,sC;AACA,U;AACA,6K;AACA,4B;AACA,4K;AACA,yI;AACA,8F;AACA,6I;AACA,G;AACA,wD;AACA,kB;;AAEA,oG;AACA,U;AACA,0B;AACA,iE;AACA,U;AACA,U;AACA,4B;AACA,+E;AACA,kH;AACA,G;AACA,E;;AAEA,G;AACA,iC;AACA,U;AACA,sJ;AACA,4B;AACA,kK;AACA,yI;AACA,8F;AACA,kG;AACA,G;AACA,mD;AACA,kB;;AAEA,oG;AACA,U;AACA,0B;AACA,gE;AACA,sD;AACA,U;AACA,U;AACA,4B;AACA,gH;AACA,G;AACA,E;;AAEA,G;AACA,iC;AACA,U;AACA,6I;AACA,4B;AACA,kK;AACA,yI;AACA,8F;AACA,kG;AACA,G;AACA,mD;AACA,kB;;AAEA,oG;AACA,U;AACA,0B;AACA,gE;AACA,sD;AACA,U;AACA,U;AACA,4B;AACA,gH;AACA,G;AACA,E;;AAEA,G;AACA,sC;AACA,U;AACA,8I;AACA,4B;AACA,wL;AACA,yI;AACA,8F;AACA,iH;AACA,G;AACA,wD;AACA,kB;;AAEA,gI;AACA,U;AACA,0B;AACA,gE;AACA,2D;AACA,U;AACA,U;AACA,4B;AACA,qH;AACA,G;AACA,E;;AAEA,6B;AACA,kF;AACA,C;;AAEA,0B;AACA,kD;AACA,yC;AACA,8C;AACA,8B;AACA,M;AACA,U;AACA,8C;AACA,4D;AACA,0C;AACA,M;AACA,G;AACA,C;;;;;;;;;;;;;;;;;;;AC1rBA,G;AACA,yE;AACA,4B;AACA,2B;AACA,sB;AACA,uB;AACA,G;AACA,kE;AACA,kB;;AAEA,8C;AACA,kC;AACA,yD;AACA,G;;AAEA,8D;AACA,2B;AACA,mC;;AAEA,uB;AACA,yM;AACA,2B;;AAEA,oB;AACA,qB;AACA,uE;AACA,2B;AACA,0E;AACA,G;AACA,8E;AACA,iG;AACA,wB;AACA,E;;AAEA,G;AACA,qC;AACA,kD;AACA,uD;AACA,uB;AACA,G;AACA,2D;AACA,kB;AACA,4B;AACA,mC;AACA,8C;AACA,wD;AACA,E;;AAEA,G;AACA,6C;AACA,U;AACA,8B;AACA,oD;AACA,E;AACA,4H;AACA,E;AACA,oG;AACA,mM;AACA,8L;AACA,E;AACA,G;AACA,0D;AACA,kB;;AAEA,sD;AACA,gC;AACA,+F;AACA,2C;AACA,wC;AACA,uE;AACA,4F;AACA,sE;AACA,+C;AACA,U;AACA,kD;AACA,2B;AACA,4F;AACA,uG;AACA,sB;AACA,oD;AACA,Y;AACA,iD;AACA,K;;AAEA,G;AACA,E;;AAEA,G;AACA,8C;AACA,U;AACA,8B;AACA,sD;AACA,E;AACA,sG;AACA,E;AACA,6G;AACA,iH;AACA,E;AACA,G;AACA,2D;AACA,kB;;AAEA,6D;AACA,yB;AACA,sD;AACA,uE;AACA,2E;AACA,mB;AACA,yD;AACA,2C;AACA,Y;AACA,2D;AACA,4F;AACA,qD;AACA,K;AACA,U;AACA,+C;AACA,G;AACA,E;;AAEA,G;AACA,6F;AACA,U;AACA,8C;AACA,G;AACA,qC;AACA,kB;;AAEA,0B;AACA,mF;AACA,G;AACA,E;AACA,wB;AACA,2F;;AAEA,kD;AACA,wB;;AAEA,qE;AACA,uD;;AAEA,+C;;AAEA,wC;AACA,kB;AACA,oC;AACA,8C;AACA,wC;AACA,mB;AACA,iE;AACA,kD;AACA,8D;AACA,oD;AACA,uD;AACA,qC;AACA,mE;AACA,iC;AACA,+D;AACA,S;AACA,yD;AACA,wE;AACA,wC;AACA,wB;AACA,8E;AACA,O;AACA,K;AACA,G;AACA,kC;AACA,Y;AACA,gC;AACA,G;;AAEA,iB;AACA,E;;AAEA,gB;AACA,2D;AACA,qD;AACA,mE;AACA,8C;AACA,mB;;AAEA,mD;AACA,mC;AACA,oB;;AAEA,kC;AACA,4C;AACA,K;;AAEA,oC;AACA,+C;AACA,K;;AAEA,mC;AACA,4D;AACA,K;;AAEA,kB;AACA,G;AACA,G;;AAEA,mD;AACA,kE;AACA,6B;AACA,kG;AACA,G;;AAEA,2D;AACA,iB;AACA,8D;AACA,G;;AAEA,uE;AACA,yC;AACA,wD;AACA,yE;AACA,gF;;AAEA,+C;AACA,mC;AACA,K;;AAEA,6C;AACA,oB;AACA,K;;AAEA,+B;AACA,C;AACA,qD","file":"/packages/cfs:file.js","sourcesContent":["/**\n * @method FS.File\n * @namespace FS.File\n * @public\n * @constructor\n * @param {object|FS.File|data to attach} [ref] Another FS.File instance, a filerecord, or some data to pass to attachData\n */\nFS.File = function(ref, createdByTransform) {\n  var self = this;\n\n  self.createdByTransform = !!createdByTransform;\n\n  if (ref instanceof FS.File || isBasicObject(ref)) {\n    // Extend self with filerecord related data\n    FS.Utility.extend(self, FS.Utility.cloneFileRecord(ref, {full: true}));\n  } else if (ref) {\n    self.attachData(ref);\n  }\n};\n\n// An FS.File can emit events\nFS.File.prototype = new EventEmitter();\n\n/**\n * @method FS.File.prototype.attachData\n * @public\n * @param {File|Blob|Buffer|ArrayBuffer|Uint8Array|String} data The data that you want to attach to the file.\n * @param {Object} [options] Options\n * @param {String} [options.type] The data content (MIME) type, if known.\n * @param {String} [options.headers] When attaching a URL, headers to be used for the GET request (currently server only)\n * @param {String} [options.auth] When attaching a URL, \"username:password\" to be used for the GET request (currently server only)\n * @param {Function} [callback] Callback function, callback(error). On the client, a callback is required if data is a URL.\n * @returns {FS.File} This FS.File instance.\n *\n */\nFS.File.prototype.attachData = function fsFileAttachData(data, options, callback) {\n  var self = this;\n\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n\n  if (!data) {\n    throw new Error('FS.File.attachData requires a data argument with some data');\n  }\n\n  var urlOpts;\n\n  // Set any other properties we can determine from the source data\n  // File\n  if (typeof File !== \"undefined\" && data instanceof File) {\n    self.name(data.name);\n    self.updatedAt(data.lastModifiedDate);\n    self.size(data.size);\n    setData(data.type);\n  }\n  // Blob\n  else if (typeof Blob !== \"undefined\" && data instanceof Blob) {\n    self.updatedAt(new Date());\n    self.size(data.size);\n    setData(data.type);\n  }\n  // URL: we need to do a HEAD request to get the type because type\n  // is required for filtering to work.\n  else if (typeof data === \"string\" && (data.slice(0, 5) === \"http:\" || data.slice(0, 6) === \"https:\")) {\n    urlOpts = FS.Utility.extend({}, options);\n    if (urlOpts.type) {\n      delete urlOpts.type;\n    }\n\n    if (!callback) {\n      if (Meteor.isClient) {\n        throw new Error('FS.File.attachData requires a callback when attaching a URL on the client');\n      }\n      var result = Meteor.call('_cfs_getUrlInfo', data, urlOpts);\n      FS.Utility.extend(self, {original: result});\n      setData(result.type);\n    } else {\n      Meteor.call('_cfs_getUrlInfo', data, urlOpts, function (error, result) {\n        FS.debug && console.log(\"URL HEAD RESULT:\", result);\n        if (error) {\n          callback(error);\n        } else {\n          FS.Utility.extend(self, {original: result});\n          setData(result.type);\n        }\n      });\n    }\n  }\n  // Everything else\n  else {\n    setData(options.type);\n  }\n\n  // Set the data\n  function setData(type) {\n    self.data = new DataMan(data, type, urlOpts);\n\n    // Update the type to match what the data is\n    self.type(self.data.type());\n\n    // Update the size to match what the data is.\n    // It's always safe to call self.data.size() without supplying a callback\n    // because it requires a callback only for URLs on the client, and we\n    // already added size for URLs when we got the result from '_cfs_getUrlInfo' method.\n    if (!self.size()) {\n      if (callback) {\n        self.data.size(function (error, size) {\n          if (error) {\n            callback && callback(error);\n          } else {\n            self.size(size);\n            setName();\n          }\n        });\n      } else {\n        self.size(self.data.size());\n        setName();\n      }\n    } else {\n      setName();\n    }\n  }\n\n  function setName() {\n    // See if we can extract a file name from URL or filepath\n    if (!self.name() && typeof data === \"string\") {\n      // name from URL\n      if (data.slice(0, 5) === \"http:\" || data.slice(0, 6) === \"https:\") {\n        if (FS.Utility.getFileExtension(data).length) {\n          // for a URL we assume the end is a filename only if it has an extension\n          self.name(FS.Utility.getFileName(data));\n        }\n      }\n      // name from filepath\n      else if (data.slice(0, 5) !== \"data:\") {\n        self.name(FS.Utility.getFileName(data));\n      }\n    }\n\n    callback && callback();\n  }\n\n  return self; //allow chaining\n};\n\n/**\n * @method FS.File.prototype.uploadProgress\n * @public\n * @returns {number} The server confirmed upload progress\n */\nFS.File.prototype.uploadProgress = function() {\n  var self = this;\n  // Make sure our file record is updated\n  self.getFileRecord();\n\n  // If fully uploaded, return 100\n  if (self.uploadedAt) {\n    return 100;\n  }\n  // Otherwise return the confirmed progress or 0\n  else {\n    return Math.round((self.chunkCount || 0) / (self.chunkSum || 1) * 100);\n  }\n};\n\n/**\n * @method FS.File.prototype.controlledByDeps\n * @public\n * @returns {FS.Collection} Returns true if this FS.File is reactive\n *\n * > Note: Returns true if this FS.File object was created by a FS.Collection\n * > and we are in a reactive computations. What does this mean? Well it should\n * > mean that our fileRecord is fully updated by Meteor and we are mounted on\n * > a collection\n */\nFS.File.prototype.controlledByDeps = function() {\n  var self = this;\n  return self.createdByTransform && Deps.active;\n};\n\n/**\n * @method FS.File.prototype.getCollection\n * @public\n * @returns {FS.Collection} Returns attached collection or undefined if not mounted\n */\nFS.File.prototype.getCollection = function() {\n  // Get the collection reference\n  var self = this;\n\n  // If we already made the link then do no more\n  if (self.collection) {\n    return self.collection;\n  }\n\n  // If we don't have a collectionName then there's not much to do, the file is\n  // not mounted yet\n  if (!self.collectionName) {\n    // Should not throw an error here - could be common that the file is not\n    // yet mounted into a collection\n    return;\n  }\n\n  // Link the collection to the file\n  self.collection = FS._collections[self.collectionName];\n\n  return self.collection; //possibly undefined, but that's desired behavior\n};\n\n/**\n * @method FS.File.prototype.isMounted\n * @public\n * @returns {FS.Collection} Returns attached collection or undefined if not mounted\n */\nFS.File.prototype.isMounted = FS.File.prototype.getCollection;\n\n/**\n * @method FS.File.prototype.getFileRecord Returns the fileRecord\n * @public\n * @returns {object} The filerecord\n */\nFS.File.prototype.getFileRecord = function() {\n  var self = this;\n  // Check if this file object fileRecord is kept updated by Meteor, if so\n  // return self\n  if (self.controlledByDeps()) {\n    return self;\n  }\n  // Go for manually updating the file record\n  if (self.isMounted()) {\n    FS.debug && console.log('GET FILERECORD: ' + self._id);\n\n    // Return the fileRecord or an empty object\n    var fileRecord = self.collection.files.findOne({_id: self._id}) || {};\n    FS.Utility.extend(self, fileRecord);\n    return fileRecord;\n  } else {\n    // We return an empty object, this way users can still do `getRecord().size`\n    // Without getting an error\n    return {};\n  }\n};\n\n/**\n * @method FS.File.prototype.update\n * @public\n * @param {modifier} modifier\n * @param {object} [options]\n * @param {function} [callback]\n *\n * Updates the fileRecord.\n */\nFS.File.prototype.update = function(modifier, options, callback) {\n  var self = this;\n\n  FS.debug && console.log('UPDATE: ' + JSON.stringify(modifier));\n\n  // Make sure we have options and callback\n  if (!callback && typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  callback = callback || FS.Utility.defaultCallback;\n\n  if (!self.isMounted()) {\n    callback(new Error(\"Cannot update a file that is not associated with a collection\"));\n    return;\n  }\n\n  // Call collection update - File record\n  return self.collection.files.update({_id: self._id}, modifier, options, function(err, count) {\n    // Update the fileRecord if it was changed and on the client\n    // The server-side methods will pull the fileRecord if needed\n    if (count > 0 && Meteor.isClient)\n      self.getFileRecord();\n    // Call callback\n    callback(err, count);\n  });\n};\n\n/**\n * @method FS.File.prototype._saveChanges\n * @private\n * @param {String} [what] \"_original\" to save original info, or a store name to save info for that store, or saves everything\n *\n * Updates the fileRecord from values currently set on the FS.File instance.\n */\nFS.File.prototype._saveChanges = function(what) {\n  var self = this;\n\n  if (!self.isMounted()) {\n    return;\n  }\n\n  FS.debug && console.log(\"FS.File._saveChanges:\", what || \"all\");\n\n  var mod = {$set: {}};\n  if (what === \"_original\") {\n    mod.$set.original = self.original;\n  } else if (typeof what === \"string\") {\n    var info = self.copies[what];\n    if (info) {\n      mod.$set[\"copies.\" + what] = info;\n    }\n  } else {\n    mod.$set.original = self.original;\n    mod.$set.copies = self.copies;\n  }\n\n  self.update(mod);\n};\n\n/**\n * @method FS.File.prototype.remove\n * @public\n * @param {Function} [callback]\n * @returns {number} Count\n *\n * Remove the current file from its FS.Collection\n */\nFS.File.prototype.remove = function(callback) {\n  var self = this;\n\n  FS.debug && console.log('REMOVE: ' + self._id);\n\n  callback = callback || FS.Utility.defaultCallback;\n\n  if (!self.isMounted()) {\n    callback(new Error(\"Cannot remove a file that is not associated with a collection\"));\n    return;\n  }\n\n  return self.collection.files.remove({_id: self._id}, function(err, res) {\n    if (!err) {\n      delete self._id;\n      delete self.collection;\n      delete self.collectionName;\n    }\n    callback(err, res);\n  });\n};\n\n/**\n * @method FS.File.prototype.moveTo\n * @param {FS.Collection} targetCollection\n * @private // Marked private until implemented\n * @todo Needs to be implemented\n *\n * Move the file from current collection to another collection\n *\n * > Note: Not yet implemented\n */\n\n/**\n * @method FS.File.prototype.getExtension Returns the lowercase file extension\n * @public\n * @deprecated Use the `extension` getter/setter method instead.\n * @param {Object} [options]\n * @param {String} [options.store] - Store name. Default is the original extension.\n * @returns {string} The extension eg.: `jpg` or if not found then an empty string ''\n */\nFS.File.prototype.getExtension = function(options) {\n  var self = this;\n  return self.extension(options);\n};\n\nfunction checkContentType(fsFile, storeName, startOfType) {\n  var type;\n  if (storeName && fsFile.hasStored(storeName)) {\n    type = fsFile.type({store: storeName});\n  } else {\n    type = fsFile.type();\n  }\n  if (typeof type === \"string\") {\n    return type.indexOf(startOfType) === 0;\n  }\n  return false;\n}\n\n/**\n * @method FS.File.prototype.isImage Is it an image file?\n * @public\n * @param {object} [options]\n * @param {string} [options.store] The store we're interested in\n *\n * Returns true if the copy of this file in the specified store has an image\n * content type. If the file object is unmounted or doesn't have a copy for\n * the specified store, or if you don't specify a store, this method checks\n * the content type of the original file.\n */\nFS.File.prototype.isImage = function(options) {\n  return checkContentType(this, (options || {}).store, 'image/');\n};\n\n/**\n * @method FS.File.prototype.isVideo Is it a video file?\n * @public\n * @param {object} [options]\n * @param {string} [options.store] The store we're interested in\n *\n * Returns true if the copy of this file in the specified store has a video\n * content type. If the file object is unmounted or doesn't have a copy for\n * the specified store, or if you don't specify a store, this method checks\n * the content type of the original file.\n */\nFS.File.prototype.isVideo = function(options) {\n  return checkContentType(this, (options || {}).store, 'video/');\n};\n\n/**\n * @method FS.File.prototype.isAudio Is it an audio file?\n * @public\n * @param {object} [options]\n * @param {string} [options.store] The store we're interested in\n *\n * Returns true if the copy of this file in the specified store has an audio\n * content type. If the file object is unmounted or doesn't have a copy for\n * the specified store, or if you don't specify a store, this method checks\n * the content type of the original file.\n */\nFS.File.prototype.isAudio = function(options) {\n  return checkContentType(this, (options || {}).store, 'audio/');\n};\n\n/**\n * @method FS.File.prototype.formattedSize\n * @public\n * @param  {Object} options\n * @param  {String} [options.store=none,display original file size] Which file do you want to get the size of?\n * @param  {String} [options.formatString='0.00 b'] The `numeral` format string to use.\n * @return {String} The file size formatted as a human readable string and reactively updated.\n *\n * * You must add the `numeral` package to your app before you can use this method.\n * * If info is not found or a size can't be determined, it will show 0.\n */\nFS.File.prototype.formattedSize = function fsFileFormattedSize(options) {\n  var self = this;\n\n  if (typeof numeral !== \"function\")\n    throw new Error(\"You must add the numeral package if you call FS.File.formattedSize\");\n\n  options = options || {};\n  options = options.hash || options;\n\n  var size = self.size(options) || 0;\n  return numeral(size).format(options.formatString || '0.00 b');\n};\n\n/**\n * @method FS.File.prototype.isUploaded Is this file completely uploaded?\n * @public\n * @returns {boolean} True if the number of uploaded bytes is equal to the file size.\n */\nFS.File.prototype.isUploaded = function() {\n  var self = this;\n\n  // Make sure we use the updated file record\n  self.getFileRecord();\n\n  return !!self.uploadedAt;\n};\n\n/**\n * @method FS.File.prototype.hasStored\n * @public\n * @param {string} storeName Name of the store\n * @param {boolean} [optimistic=false] In case that the file record is not found, read below\n * @returns {boolean} Is a version of this file stored in the given store?\n *\n * > Note: If the file is not published to the client or simply not found:\n * this method cannot know for sure if it exists or not. The `optimistic`\n * param is the boolean value to return. Are we `optimistic` that the copy\n * could exist. This is the case in `FS.File.url` we are optimistic that the\n * copy supplied by the user exists.\n */\nFS.File.prototype.hasStored = function(storeName, optimistic) {\n  var self = this;\n  // Make sure we use the updated file record\n  self.getFileRecord();\n  // If we havent the published data then\n  if (FS.Utility.isEmpty(self.copies)) {\n    return !!optimistic;\n  }\n  if (typeof storeName === \"string\") {\n    // Return true only if the `key` property is present, which is not set until\n    // storage is complete.\n    return !!(self.copies && self.copies[storeName] && self.copies[storeName].key);\n  }\n  return false;\n};\n\n// Backwards compatibility\nFS.File.prototype.hasCopy = FS.File.prototype.hasStored;\n\n/**\n * @method FS.File.prototype.getCopyInfo\n * @public\n * @deprecated Use individual methods with `store` option instead.\n * @param {string} storeName Name of the store for which to get copy info.\n * @returns {Object} The file details, e.g., name, size, key, etc., specific to the copy saved in this store.\n */\nFS.File.prototype.getCopyInfo = function(storeName) {\n  var self = this;\n  // Make sure we use the updated file record\n  self.getFileRecord();\n  return (self.copies && self.copies[storeName]) || null;\n};\n\n/**\n * @method FS.File.prototype._getInfo\n * @private\n * @param {String} [storeName] Name of the store for which to get file info. Omit for original file details.\n * @param {Object} [options]\n * @param {Boolean} [options.updateFileRecordFirst=false] Update this instance with data from the DB first?\n * @returns {Object} The file details, e.g., name, size, key, etc. If not found, returns an empty object.\n */\nFS.File.prototype._getInfo = function(storeName, options) {\n  var self = this;\n  options = options || {};\n\n  if (options.updateFileRecordFirst) {\n    // Make sure we use the updated file record\n    self.getFileRecord();\n  }\n\n  if (storeName) {\n    return (self.copies && self.copies[storeName]) || {};\n  } else {\n    return self.original || {};\n  }\n};\n\n/**\n * @method FS.File.prototype._setInfo\n * @private\n * @param {String} storeName - Name of the store for which to set file info. Non-string will set original file details.\n * @param {String} property - Property to set\n * @param {String} value - New value for property\n * @param {Boolean} save - Should the new value be saved to the DB, too, or just set in the FS.File properties?\n * @returns {undefined}\n */\nFS.File.prototype._setInfo = function(storeName, property, value, save) {\n  var self = this;\n  if (typeof storeName === \"string\") {\n    self.copies = self.copies || {};\n    self.copies[storeName] = self.copies[storeName] || {};\n    self.copies[storeName][property] = value;\n    save && self._saveChanges(storeName);\n  } else {\n    self.original = self.original || {};\n    self.original[property] = value;\n    save && self._saveChanges(\"_original\");\n  }\n};\n\n/**\n * @method FS.File.prototype.name\n * @public\n * @param {String|null} [value] - If setting the name, specify the new name as the first argument. Otherwise the options argument should be first.\n * @param {Object} [options]\n * @param {Object} [options.store=none,original] - Get or set the name of the version of the file that was saved in this store. Default is the original file name.\n * @param {Boolean} [options.updateFileRecordFirst=false] Update this instance with data from the DB first? Applies to getter usage only.\n * @param {Boolean} [options.save=true] Save change to database? Applies to setter usage only.\n * @returns {String|undefined} If setting, returns `undefined`. If getting, returns the file name.\n */\nFS.File.prototype.name = function(value, options) {\n  var self = this;\n\n  if (!options && ((typeof value === \"object\" && value !== null) || typeof value === \"undefined\")) {\n    // GET\n    options = value || {};\n    options = options.hash || options; // allow use as UI helper\n    return self._getInfo(options.store, options).name;\n  } else {\n    // SET\n    options = options || {};\n    return self._setInfo(options.store, 'name', value, typeof options.save === \"boolean\" ? options.save : true);\n  }\n};\n\n/**\n * @method FS.File.prototype.extension\n * @public\n * @param {String|null} [value] - If setting the extension, specify the new extension (without period) as the first argument. Otherwise the options argument should be first.\n * @param {Object} [options]\n * @param {Object} [options.store=none,original] - Get or set the extension of the version of the file that was saved in this store. Default is the original file extension.\n * @param {Boolean} [options.updateFileRecordFirst=false] Update this instance with data from the DB first? Applies to getter usage only.\n * @param {Boolean} [options.save=true] Save change to database? Applies to setter usage only.\n * @returns {String|undefined} If setting, returns `undefined`. If getting, returns the file extension or an empty string if there isn't one.\n */\nFS.File.prototype.extension = function(value, options) {\n  var self = this;\n\n  if (!options && ((typeof value === \"object\" && value !== null) || typeof value === \"undefined\")) {\n    // GET\n    options = value || {};\n    return FS.Utility.getFileExtension(self.name(options) || '');\n  } else {\n    // SET\n    options = options || {};\n    var newName = FS.Utility.setFileExtension(self.name(options) || '', value);\n    return self._setInfo(options.store, 'name', newName, typeof options.save === \"boolean\" ? options.save : true);\n  }\n};\n\n/**\n * @method FS.File.prototype.size\n * @public\n * @param {Number} [value] - If setting the size, specify the new size in bytes as the first argument. Otherwise the options argument should be first.\n * @param {Object} [options]\n * @param {Object} [options.store=none,original] - Get or set the size of the version of the file that was saved in this store. Default is the original file size.\n * @param {Boolean} [options.updateFileRecordFirst=false] Update this instance with data from the DB first? Applies to getter usage only.\n * @param {Boolean} [options.save=true] Save change to database? Applies to setter usage only.\n * @returns {Number|undefined} If setting, returns `undefined`. If getting, returns the file size.\n */\nFS.File.prototype.size = function(value, options) {\n  var self = this;\n\n  if (!options && ((typeof value === \"object\" && value !== null) || typeof value === \"undefined\")) {\n    // GET\n    options = value || {};\n    options = options.hash || options; // allow use as UI helper\n    return self._getInfo(options.store, options).size;\n  } else {\n    // SET\n    options = options || {};\n    return self._setInfo(options.store, 'size', value, typeof options.save === \"boolean\" ? options.save : true);\n  }\n};\n\n/**\n * @method FS.File.prototype.type\n * @public\n * @param {String} [value] - If setting the type, specify the new type as the first argument. Otherwise the options argument should be first.\n * @param {Object} [options]\n * @param {Object} [options.store=none,original] - Get or set the type of the version of the file that was saved in this store. Default is the original file type.\n * @param {Boolean} [options.updateFileRecordFirst=false] Update this instance with data from the DB first? Applies to getter usage only.\n * @param {Boolean} [options.save=true] Save change to database? Applies to setter usage only.\n * @returns {String|undefined} If setting, returns `undefined`. If getting, returns the file type.\n */\nFS.File.prototype.type = function(value, options) {\n  var self = this;\n\n  if (!options && ((typeof value === \"object\" && value !== null) || typeof value === \"undefined\")) {\n    // GET\n    options = value || {};\n    options = options.hash || options; // allow use as UI helper\n    return self._getInfo(options.store, options).type;\n  } else {\n    // SET\n    options = options || {};\n    return self._setInfo(options.store, 'type', value, typeof options.save === \"boolean\" ? options.save : true);\n  }\n};\n\n/**\n * @method FS.File.prototype.updatedAt\n * @public\n * @param {String} [value] - If setting updatedAt, specify the new date as the first argument. Otherwise the options argument should be first.\n * @param {Object} [options]\n * @param {Object} [options.store=none,original] - Get or set the last updated date for the version of the file that was saved in this store. Default is the original last updated date.\n * @param {Boolean} [options.updateFileRecordFirst=false] Update this instance with data from the DB first? Applies to getter usage only.\n * @param {Boolean} [options.save=true] Save change to database? Applies to setter usage only.\n * @returns {String|undefined} If setting, returns `undefined`. If getting, returns the file's last updated date.\n */\nFS.File.prototype.updatedAt = function(value, options) {\n  var self = this;\n\n  if (!options && ((typeof value === \"object\" && value !== null && !(value instanceof Date)) || typeof value === \"undefined\")) {\n    // GET\n    options = value || {};\n    options = options.hash || options; // allow use as UI helper\n    return self._getInfo(options.store, options).updatedAt;\n  } else {\n    // SET\n    options = options || {};\n    return self._setInfo(options.store, 'updatedAt', value, typeof options.save === \"boolean\" ? options.save : true);\n  }\n};\n\nfunction isBasicObject(obj) {\n  return (obj === Object(obj) && Object.getPrototypeOf(obj) === Object.prototype);\n}\n\n// getPrototypeOf polyfill\nif (typeof Object.getPrototypeOf !== \"function\") {\n  if (typeof \"\".__proto__ === \"object\") {\n    Object.getPrototypeOf = function(object) {\n      return object.__proto__;\n    };\n  } else {\n    Object.getPrototypeOf = function(object) {\n      // May break if the constructor has been tampered with\n      return object.constructor.prototype;\n    };\n  }\n}\n","/**\n * Notes a details about a storage adapter failure within the file record\n * @param {string} storeName\n * @param {number} maxTries\n * @return {undefined}\n * @todo deprecate this\n */\nFS.File.prototype.logCopyFailure = function(storeName, maxTries) {\n  var self = this;\n\n  // hasStored will update from the fileRecord\n  if (self.hasStored(storeName)) {\n    throw new Error(\"logCopyFailure: invalid storeName\");\n  }\n\n  // Make sure we have a temporary file saved since we will be\n  // trying the save again.\n  FS.TempStore.ensureForFile(self);\n\n  var now = new Date();\n  var currentCount = (self.failures && self.failures.copies && self.failures.copies[storeName] && typeof self.failures.copies[storeName].count === \"number\") ? self.failures.copies[storeName].count : 0;\n  maxTries = maxTries || 5;\n\n  var modifier = {};\n  modifier.$set = {};\n  modifier.$set['failures.copies.' + storeName + '.lastAttempt'] = now;\n  if (currentCount === 0) {\n    modifier.$set['failures.copies.' + storeName + '.firstAttempt'] = now;\n  }\n  modifier.$set['failures.copies.' + storeName + '.count'] = currentCount + 1;\n  modifier.$set['failures.copies.' + storeName + '.doneTrying'] = (currentCount + 1 >= maxTries);\n  self.update(modifier);\n};\n\n/**\n * Has this store permanently failed?\n * @param {String} storeName The name of the store\n * @return {boolean} Has this store failed permanently?\n * @todo deprecate this\n */\nFS.File.prototype.failedPermanently = function(storeName) {\n  var self = this;\n  return !!(self.failures &&\n            self.failures.copies &&\n            self.failures.copies[storeName] &&\n            self.failures.copies[storeName].doneTrying);\n};\n\n/**\n * @method FS.File.prototype.createReadStream\n * @public\n * @param {String} [storeName]\n * @returns {stream.Readable} Readable NodeJS stream\n *\n * Returns a readable stream. Where the stream reads from depends on the FS.File instance and whether you pass a store name.\n *\n * * If you pass a `storeName`, a readable stream for the file data saved in that store is returned.\n * * If you don't pass a `storeName` and data is attached to the FS.File instance (on `data` property, which must be a DataMan instance), then a readable stream for the attached data is returned.\n * * If you don't pass a `storeName` and there is no data attached to the FS.File instance, a readable stream for the file data currently in the temporary store (`FS.TempStore`) is returned.\n *\n */\nFS.File.prototype.createReadStream = function(storeName) {\n  var self = this;\n\n  // If we dont have a store name but got Buffer data?\n  if (!storeName && self.data) {\n    FS.debug && console.log(\"fileObj.createReadStream creating read stream for attached data\");\n    // Stream from attached data if present\n    return self.data.createReadStream();\n  } else if (!storeName && FS.TempStore && FS.TempStore.exists(self)) {\n    FS.debug && console.log(\"fileObj.createReadStream creating read stream for temp store\");\n    // Stream from temp store - its a bit slower than regular streams?\n    return FS.TempStore.createReadStream(self);\n  } else {\n    // Stream from the store using storage adapter\n    if (self.isMounted()) {\n      var storage = self.collection.storesLookup[storeName] || self.collection.primaryStore;\n      FS.debug && console.log(\"fileObj.createReadStream creating read stream for store\", storage.name);\n      // return stream\n      return storage.adapter.createReadStream(self);\n    } else {\n      throw new Meteor.Error('File not mounted');\n    }\n\n  }\n};\n\n/**\n * @method FS.File.prototype.createWriteStream\n * @public\n * @param {String} [storeName]\n * @returns {stream.Writeable} Writeable NodeJS stream\n *\n * Returns a writeable stream. Where the stream writes to depends on whether you pass in a store name.\n *\n * * If you pass a `storeName`, a writeable stream for (over)writing the file data in that store is returned.\n * * If you don't pass a `storeName`, a writeable stream for writing to the temp store for this file is returned.\n *\n */\nFS.File.prototype.createWriteStream = function(storeName) {\n  var self = this;\n\n  // We have to have a mounted file in order for this to work\n  if (self.isMounted()) {\n    if (!storeName && FS.TempStore && FS.FileWorker) {\n      // If we have worker installed - we pass the file to FS.TempStore\n      // We dont need the storeName since all stores will be generated from\n      // TempStore.\n      // This should trigger FS.FileWorker at some point?\n      FS.TempStore.createWriteStream(self);\n    } else {\n      // Stream directly to the store using storage adapter\n      var storage = self.collection.storesLookup[storeName] || self.collection.primaryStore;\n      return storage.adapter.createWriteStream(self);\n    }\n  } else {\n    throw new Meteor.Error('File not mounted');\n  }\n};\n\n/**\n * @method FS.File.prototype.copy Makes a copy of the file and underlying data in all stores.\n * @public\n * @returns {FS.File} The new FS.File instance\n */\nFS.File.prototype.copy = function() {\n  var self = this;\n\n  if (!self.isMounted()) {\n    throw new Error(\"Cannot copy a file that is not associated with a collection\");\n  }\n  \n  // Get the file record\n  var fileRecord = self.collection.files.findOne({_id: self._id}, {transform: null}) || {};\n\n  // Remove _id and copy keys from the file record\n  delete fileRecord._id;\n\n  // Insert directly; we don't have access to \"original\" in this case\n  var newId = self.collection.files.insert(fileRecord);\n\n  var newFile = self.collection.findOne(newId);\n\n  // Copy underlying files in the stores\n  var mod, oldKey;\n  for (var name in newFile.copies) {\n    if (newFile.copies.hasOwnProperty(name)) {\n      oldKey = newFile.copies[name].key;\n      if (oldKey) {\n        // We need to ask the adapter for the true oldKey because\n        // right now gridfs does some extra stuff.\n        // TODO GridFS should probably set the full key object\n        // (with _id and filename) into `copies.key`\n        // so that copies.key can be passed directly to\n        // createReadStreamForFileKey\n        var sourceFileStorage = self.collection.storesLookup[name];\n        if (!sourceFileStorage) {\n          throw new Error(name + \" is not a valid store name\");\n        }\n        oldKey = sourceFileStorage.adapter.fileKey(self);\n        // delete so that new fileKey will be generated in copyStoreData\n        delete newFile.copies[name].key;\n        mod = mod || {};\n        mod[\"copies.\" + name + \".key\"] = copyStoreData(newFile, name, oldKey);\n      }\n    }\n  }\n  // Update keys in the filerecord\n  if (mod) {\n    newFile.update({$set: mod});\n  }\n\n  return newFile;\n};\n\nMeteor.methods({\n  // Does a HEAD request to URL to get the type, updatedAt,\n  // and size prior to actually downloading the data.\n  // That way we can do filter checks without actually downloading.\n  '_cfs_getUrlInfo': function (url, options) {\n    this.unblock();\n\n    var response = HTTP.call(\"HEAD\", url, options);\n    var headers = response.headers;\n    var result = {};\n\n    if (headers['content-type']) {\n      result.type = headers['content-type'];\n    }\n\n    if (headers['content-length']) {\n      result.size = +headers['content-length'];\n    }\n\n    if (headers['last-modified']) {\n      result.updatedAt = new Date(headers['last-modified']);\n    }\n\n    return result;\n  }\n});\n\n// TODO maybe this should be in cfs-storage-adapter\nfunction _copyStoreData(fileObj, storeName, sourceKey, callback) {\n  if (!fileObj.isMounted()) {\n    throw new Error(\"Cannot copy store data for a file that is not associated with a collection\");\n  }\n\n  var storage = fileObj.collection.storesLookup[storeName];\n  if (!storage) {\n    throw new Error(storeName + \" is not a valid store name\");\n  }\n\n  // We want to prevent beforeWrite and transformWrite from running, so\n  // we interact directly with the store.\n  var destinationKey = storage.adapter.fileKey(fileObj);\n  var readStream = storage.adapter.createReadStreamForFileKey(sourceKey);\n  var writeStream = storage.adapter.createWriteStreamForFileKey(destinationKey);\n\n  writeStream.once('stored', function(result) {\n    callback(null, result.fileKey);\n  });\n\n  writeStream.once('error', function(error) {\n    callback(error);\n  });\n\n  readStream.pipe(writeStream);\n}\nvar copyStoreData = Meteor.wrapAsync(_copyStoreData);\n"]}