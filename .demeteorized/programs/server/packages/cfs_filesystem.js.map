{"version":3,"file":"/packages/cfs:filesystem.js","sources":["cfs:filesystem/filesystem.server.js"],"names":[],"mappings":";;;;;;;;;;;;;;AAAA,2B;AACA,+B;AACA,mC;AACA,yC;;AAEA,+C;AACA,kB;AACA,6C;AACA,iE;;AAEA,6D;AACA,yE;;AAEA,gF;AACA,8B;AACA,4E;AACA,uF;AACA,G;;AAEA,gB;AACA,oE;;AAEA,iC;AACA,4C;AACA,uF;AACA,mB;AACA,iD;AACA,Y;AACA,2E;AACA,K;AACA,G;;AAEA,sB;AACA,4C;;AAEA,2B;AACA,4B;AACA,4E;;AAEA,+C;AACA,mC;AACA,gC;AACA,wB;AACA,oD;AACA,qD;AACA,+C;;AAEA,oC;AACA,wD;;AAEA,0D;AACA,8F;AACA,M;AACA,kD;AACA,0C;AACA,sD;;AAEA,8D;AACA,oD;AACA,M;AACA,mD;AACA,8B;;AAEA,0C;AACA,sD;;AAEA,iC;AACA,gE;;AAEA,wE;AACA,oC;AACA,0C;AACA,uF;;AAEA,2F;AACA,uF;AACA,qE;AACA,a;AACA,sC;AACA,4C;;AAEA,oE;AACA,sC;AACA,6B;AACA,6B;AACA,iC;AACA,a;;AAEA,sB;AACA,0C;AACA,yC;AACA,S;AACA,S;;AAEA,yB;AACA,M;AACA,yC;AACA,0C;AACA,sD;;AAEA,8B;AACA,oD;AACA,0C;AACA,2G;AACA,qC;AACA,gB;AACA,8C;AACA,S;AACA,S;AACA,M;AACA,wC;AACA,0C;AACA,sD;AACA,2C;AACA,oC;AACA,c;AACA,qC;AACA,O;AACA,K;AACA,2F;AACA,kC;AACA,qC;AACA,qD;AACA,U;;AAEA,6D;;AAEA,8E;AACA,4F;AACA,6E;AACA,kD;AACA,2C;AACA,wB;AACA,8B;AACA,+B;AACA,c;AACA,2B;AACA,qB;AACA,a;AACA,gF;AACA,kD;AACA,2C;AACA,wB;AACA,8B;AACA,+B;AACA,c;AACA,2B;AACA,qB;AACA,a;AACA,yE;AACA,iD;AACA,2B;AACA,qB;AACA,a;AACA,Q;AACA,K;AACA,E","sourcesContent":["var fs = Npm.require('fs');\nvar path = Npm.require('path');\nvar mkdirp = Npm.require('mkdirp');\n//var chokidar = Npm.require('chokidar');\n\nFS.Store.FileSystem = function(name, options) {\n  var self = this;\n  if (!(self instanceof FS.Store.FileSystem))\n    throw new Error('FS.Store.FileSystem missing keyword \"new\"');\n\n  // We allow options to be string/path empty or options.path\n  options = (options !== ''+options) ? options || {} : { path: options };\n\n  // Provide a default FS directory one level up from the build/bundle directory\n  var pathname = options.path;\n  if (!pathname && __meteor_bootstrap__ && __meteor_bootstrap__.serverDir) {\n    pathname = path.join(__meteor_bootstrap__.serverDir, '../../../cfs/files/' + name);\n  }\n\n  if (!pathname)\n    throw new Error('FS.Store.FileSystem unable to determine path');\n\n  // Check if we have '~/foo/bar'\n  if (pathname.split(path.sep)[0] === '~') {\n    var homepath = process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE;\n    if (homepath) {\n      pathname = pathname.replace('~', homepath);\n    } else {\n      throw new Error('FS.Store.FileSystem unable to resolve \"~\" in path');\n    }\n  }\n\n  // Set absolute path\n  var absolutePath = path.resolve(pathname);\n\n  // Ensure the path exists\n  mkdirp.sync(absolutePath);\n  FS.debug && console.log(name + ' FileSystem mounted on: ' + absolutePath);\n\n  return new FS.StorageAdapter(name, options, {\n    typeName: 'storage.filesystem',\n    fileKey: function(fileObj) {\n      // Lookup the copy\n      var store = fileObj && fileObj._getInfo(name);\n      // If the store and key is found return the key\n      if (store && store.key) return store.key;\n\n      var filename = fileObj.name();\n      var filenameInStore = fileObj.name({store: name});\n\n      // If no store key found we resolve / generate a key\n      return fileObj.collectionName + '-' + fileObj._id + '-' + (filenameInStore || filename);\n    },\n    createReadStream: function(fileKey, options) {\n      // this is the Storage adapter scope\n      var filepath = path.join(absolutePath, fileKey);\n\n      // return the read stream - Options allow { start, end }\n      return fs.createReadStream(filepath, options);\n    },\n    createWriteStream: function(fileKey, options) {\n      options = options || {};\n\n      // this is the Storage adapter scope\n      var filepath = path.join(absolutePath, fileKey);\n\n      // Return the stream handle\n      var writeStream = fs.createWriteStream(filepath, options);\n\n      // The filesystem does not emit the \"end\" event only close - so we\n      // manually send the end event\n      writeStream.on('close', function() {\n        if (FS.debug) console.log('SA FileSystem - DONE!! fileKey: \"' + fileKey + '\"');\n\n        // Get the exact size of the stored file, so that we can pass it to onEnd/onStored.\n        // Since stream transforms might have altered the size, this is the best way to\n        // ensure we update the fileObj.copies with the correct size.\n        try {\n          // Get the stats of the file\n          var stats = fs.statSync(filepath);\n\n          // Emit end and return the fileKey, size, and updated date\n          writeStream.emit('stored', {\n            fileKey: fileKey,\n            size: stats.size,\n            storedAt: stats.mtime\n          });\n\n        } catch(err) {\n          // On error we emit the error on\n          writeStream.emit('error', err);\n        }\n      });\n\n      return writeStream;\n    },\n    remove: function(fileKey, callback) {\n      // this is the Storage adapter scope\n      var filepath = path.join(absolutePath, fileKey);\n\n      // Call node unlink file\n      fs.unlink(filepath, function (error, result) {\n        if (error && error.errno === 34) {\n          console.warn(\"SA FileSystem: Could not delete \" + filepath + \" because the file was not found.\");\n          callback && callback(null);\n        } else {\n          callback && callback(error, result);\n        }\n      });\n    },\n    stats: function(fileKey, callback) {\n      // this is the Storage adapter scope\n      var filepath = path.join(absolutePath, fileKey);\n      if (typeof callback === 'function') {\n        fs.stat(filepath, callback);\n      } else {\n        return fs.statSync(filepath);\n      }\n    }\n    // Add this back and add the chokidar dependency back when we make this work eventually\n    // watch: function(callback) {\n    //   function fileKey(filePath) {\n    //     return filePath.replace(absolutePath, \"\");\n    //   }\n\n    //   FS.debug && console.log('Watching ' + absolutePath);\n\n    //   // chokidar seems to be most widely used and production ready watcher\n    //   var watcher = chokidar.watch(absolutePath, {ignored: /\\/\\./, ignoreInitial: true});\n    //   watcher.on('add', Meteor.bindEnvironment(function(filePath, stats) {\n    //     callback(\"change\", fileKey(filePath), {\n    //       name: path.basename(filePath),\n    //       type: null,\n    //       size: stats.size,\n    //       utime: stats.mtime\n    //     });\n    //   }, function(err) {\n    //     throw err;\n    //   }));\n    //   watcher.on('change', Meteor.bindEnvironment(function(filePath, stats) {\n    //     callback(\"change\", fileKey(filePath), {\n    //       name: path.basename(filePath),\n    //       type: null,\n    //       size: stats.size,\n    //       utime: stats.mtime\n    //     });\n    //   }, function(err) {\n    //     throw err;\n    //   }));\n    //   watcher.on('unlink', Meteor.bindEnvironment(function(filePath) {\n    //     callback(\"remove\", fileKey(filePath));\n    //   }, function(err) {\n    //     throw err;\n    //   }));\n    // }\n  });\n};\n"]}