{"version":3,"file":"/packages/cfs:base-package.js","sources":["cfs:base-package/base-common.js","cfs:base-package/base-server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA,qB;AACA,Q;;AAEA,uF;AACA,Y;AACA,uB;AACA,sF;AACA,I;AACA,2B;AACA,8F;AACA,I;AACA,mB;AACA,8E;AACA,G;AACA,E;;AAEA,8B;AACA,oB;;AAEA,2B;AACA,gB;;AAEA,kE;AACA,e;;AAEA,mC;AACA,qB;;AAEA,a;AACA,c;;AAEA,gF;AACA,E;AACA,U;AACA,E;AACA,gF;;AAEA,gC;AACA,W;AACA,4D;AACA,I;AACA,sC;AACA,qB;AACA,E;;AAEA,G;AACA,qC;AACA,U;AACA,gD;AACA,4B;AACA,oH;AACA,sC;AACA,E;AACA,yF;AACA,6E;AACA,c;AACA,E;AACA,wF;AACA,uD;AACA,E;AACA,oF;AACA,iB;AACA,E;AACA,mG;AACA,E;AACA,uF;AACA,yF;AACA,iC;AACA,E;AACA,G;AACA,qD;AACA,0B;AACA,kB;AACA,6F;AACA,4F;AACA,+F;AACA,8B;AACA,gG;AACA,yB;AACA,8D;AACA,+B;AACA,K;AACA,G;AACA,gB;AACA,E;;AAEA,G;AACA,qC;AACA,U;AACA,uB;AACA,uB;AACA,E;AACA,6E;AACA,oD;AACA,G;AACA,4D;AACA,Y;AACA,wC;AACA,sC;AACA,iC;AACA,Y;AACA,uC;AACA,gB;AACA,K;;AAEA,G;AACA,E;;AAEA,G;AACA,qC;AACA,U;AACA,wF;AACA,+E;AACA,4C;AACA,E;AACA,8E;AACA,6E;AACA,wE;AACA,G;AACA,mD;AACA,iB;AACA,2E;AACA,gB;AACA,qD;AACA,a;AACA,iC;AACA,C;;AAEA,G;AACA,0B;AACA,U;AACA,mD;AACA,G;AACA,gC;;AAEA,G;AACA,yB;AACA,W;AACA,iG;AACA,0F;AACA,4E;AACA,uB;AACA,E;AACA,wE;AACA,mE;AACA,G;AACA,kF;AACA,uC;AACA,yC;;AAEA,qE;AACA,sB;AACA,iC;AACA,6B;AACA,oE;AACA,W;AACA,G;;AAEA,wD;AACA,6B;AACA,+C;AACA,G;;AAEA,gE;AACA,0B;;AAEA,wC;AACA,iD;AACA,sC;AACA,O;AACA,iD;AACA,G;AACA,wE;AACA,kD;AACA,uC;AACA,O;AACA,iD;AACA,G;AACA,E;;AAEA,G;AACA,iC;AACA,W;AACA,sD;AACA,4E;AACA,G;AACA,yD;AACA,yD;AACA,sC;AACA,4B;AACA,oC;AACA,wC;AACA,yB;AACA,qC;AACA,G;AACA,c;AACA,E;;AAEA,G;AACA,sC;AACA,U;AACA,6F;AACA,4E;AACA,G;AACA,mE;AACA,sC;AACA,kC;AACA,oC;AACA,0C;AACA,+D;AACA,2D;AACA,gE;AACA,E;;AAEA,G;AACA,sC;AACA,U;AACA,mF;AACA,+G;AACA,yD;AACA,G;AACA,wE;AACA,8B;AACA,gB;AACA,G;AACA,qD;AACA,0B;AACA,uD;AACA,U;AACA,4B;AACA,G;AACA,c;AACA,E;;AAEA,E;AACA,mC;AACA,G;AACA,yD;AACA,e;AACA,uC;AACA,mB;AACA,oB;AACA,gF;AACA,K;AACA,2C;AACA,E;;AAEA,sD;AACA,kF;AACA,E;;AAEA,E;AACA,4C;AACA,G;;AAEA,kD;AACA,a;;AAEA,8B;AACA,iB;AACA,U;AACA,kD;AACA,G;;AAEA,mC;AACA,E;;AAEA,gD;AACA,mC;AACA,a;AACA,qB;AACA,6C;AACA,a;AACA,iC;AACA,U;AACA,4E;AACA,G;AACA,E;;AAEA,kD;AACA,sD;AACA,E;;AAEA,gD;AACA,mC;AACA,a;AACA,qB;AACA,6C;AACA,a;AACA,iC;AACA,U;AACA,4E;AACA,G;AACA,E;;AAEA,2C;AACA,6B;;AAEA,yB;;AAEA,+B;;AAEA,+B;;AAEA,+B;;AAEA,uB;;AAEA,yB;;AAEA,+B;;AAEA,yB;;;;;;;;;;;;;;;;;;;ACxTA,G;AACA,oC;AACA,U;AACA,2B;AACA,oB;AACA,E;AACA,2D;AACA,G;AACA,4C;AACA,wB;AACA,+B;AACA,iC;AACA,wB;AACA,G;AACA,gB;AACA,E;;AAEA,G;AACA,oC;AACA,U;AACA,uB;AACA,wB;AACA,E;AACA,2D;AACA,G;AACA,4C;AACA,wB;AACA,oC;AACA,iC;AACA,wB;AACA,G;AACA,gB;AACA,E;;AAEA,+C;AACA,yC;AACA,0E;AACA,E;;AAEA,oD;AACA,yD;AACA,kF;;AAEA,8B;AACA,gD;AACA,kE;AACA,I;;AAEA,8B;AACA,kD;AACA,oE;AACA,I;;AAEA,iD;AACA,oB;AACA,E","sourcesContent":["// Exported namespace\nFS = {};\n\n// namespace for adapters; XXX should this be added by cfs-storage-adapter pkg instead?\nFS.Store = {\n  GridFS: function () {\n    throw new Error('To use FS.Store.GridFS, you must add the \"cfs-gridfs\" package.');\n  },\n  FileSystem: function () {\n    throw new Error('To use FS.Store.FileSystem, you must add the \"cfs-filesystem\" package.');\n  },\n  S3: function () {\n    throw new Error('To use FS.Store.S3, you must add the \"cfs-s3\" package.');\n  }\n};\n\n// namespace for access points\nFS.AccessPoint = {};\n\n// namespace for utillities\nFS.Utility = {};\n\n// A general place for any package to store global config settings\nFS.config = {};\n\n// An internal collection reference\nFS._collections = {};\n\n// Test scope\n_Utility = {};\n\n// #############################################################################\n//\n// HELPERS\n//\n// #############################################################################\n\n/** @method _Utility.defaultZero\n * @private\n  * @param {Any} val Returns number or 0 if value is a falsy\n  */\n_Utility.defaultZero = function(val) {\n  return +(val || 0);\n};\n\n/**\n * @method FS.Utility.cloneFileRecord\n * @public\n * @param {FS.File|FS.Collection filerecord} rec\n * @param {Object} [options]\n * @param {Boolean} [options.full=false] Set `true` to prevent certain properties from being omitted from the clone.\n * @returns {Object} Cloned filerecord\n *\n * Makes a shallow clone of `rec`, filtering out some properties that might be present if\n * it's an FS.File instance, but which we never want to be part of the stored\n * filerecord.\n *\n * This is a blacklist clone rather than a whitelist because we want the user to be able\n * to specify whatever additional properties they wish.\n *\n * In general, we expect the following whitelist properties used by the internal and\n * external APIs:\n *\n * _id, name, size, type, chunkCount, chunkSize, chunkSum, copies, createdAt, updatedAt, uploadedAt\n *\n * Those properties, and any additional properties added by the user, should be present\n * in the returned object, which is suitable for inserting into the backing collection or\n * extending an FS.File instance.\n *\n */\nFS.Utility.cloneFileRecord = function(rec, options) {\n  options = options || {};\n  var result = {};\n  // We use this method for two purposes. If using it to clone one FS.File into another, then\n  // we want a full clone. But if using it to get a filerecord object for inserting into the\n  // internal collection, then there are certain properties we want to omit so that they aren't\n  // stored in the collection.\n  var omit = options.full ? [] : ['collectionName', 'collection', 'data', 'createdByTransform'];\n  for (var prop in rec) {\n    if (rec.hasOwnProperty(prop) && !_.contains(omit, prop)) {\n      result[prop] = rec[prop];\n    }\n  }\n  return result;\n};\n\n/**\n * @method FS.Utility.defaultCallback\n * @public\n * @param {Error} [err]\n * @returns {undefined}\n *\n * Can be used as a default callback for client methods that need a callback.\n * Simply throws the provided error if there is one.\n */\nFS.Utility.defaultCallback = function defaultCallback(err) {\n  if (err) {\n    // Show gentle error if Meteor error\n    if (err instanceof Meteor.Error) {\n      console.error(err.message);\n    } else {\n      // Normal error, just throw error\n      throw err;\n    }\n\n  }\n};\n\n/**\n * @method FS.Utility.defaultCallback\n * @public\n * @param {Function} [f] A callback function, if you have one. Can be undefined or null.\n * @param {Meteor.Error | Error | String} [err] Error or error message (string)\n * @returns {Any} the callback result if any\n *\n * Handle Error, creates an Error instance with the given text. If callback is\n * a function, passes the error to that function. Otherwise throws it. Useful\n * for dealing with errors in methods that optionally accept a callback.\n */\nFS.Utility.handleError = function(f, err, result) {\n  // Set callback\n  var callback = (typeof f === 'function')? f : FS.Utility.defaultCallback;\n  // Set the err\n  var error = (err === ''+err)? new Error(err) : err;\n  // callback\n  return callback(error, result);\n}\n\n/**\n * @method FS.Utility.noop\n * @public\n * Use this to hand a no operation / empty function\n */\nFS.Utility.noop = function() {};\n\n/**\n * @method validateAction\n * @private\n * @param {Object} validators - The validators object to use, with `deny` and `allow` properties.\n * @param {FS.File} fileObj - Mounted or mountable file object to be passed to validators.\n * @param {String} userId - The ID of the user who is attempting the action.\n * @returns {undefined}\n *\n * Throws a \"400-Bad Request\" Meteor error if the file is not mounted or\n * a \"400-Access denied\" Meteor error if the action is not allowed.\n */\nFS.Utility.validateAction = function validateAction(validators, fileObj, userId) {\n  var denyValidators = validators.deny;\n  var allowValidators = validators.allow;\n\n  // If insecure package is used and there are no validators defined,\n  // allow the action.\n  if (typeof Package === 'object'\n          && Package.insecure\n          && denyValidators.length + allowValidators.length === 0) {\n    return;\n  }\n\n  // Validators should receive a fileObj that is mounted\n  if (!fileObj.isMounted()) {\n    throw new Meteor.Error(400, \"Bad Request\");\n  }\n\n  // Validators should receive a fileObj that is fully populated\n  fileObj.getFileRecord();\n\n  // Any deny returns true means denied.\n  if (_.any(denyValidators, function(validator) {\n    return validator(userId, fileObj);\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n  // Any allow returns true means proceed. Throw error if they all fail.\n  if (_.all(allowValidators, function(validator) {\n    return !validator(userId, fileObj);\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n};\n\n/**\n * @method FS.Utility.getFileName\n * @private\n * @param {String} name - A filename, filepath, or URL\n * @returns {String} The filename without the URL, filepath, or query string\n */\nFS.Utility.getFileName = function utilGetFileName(name) {\n  // in case it's a URL, strip off potential query string\n  // should have no effect on filepath\n  name = name.split('?')[0];\n  // strip off beginning path or url\n  var lastSlash = name.lastIndexOf('/');\n  if (lastSlash !== -1) {\n    name = name.slice(lastSlash + 1);\n  }\n  return name;\n};\n\n/**\n * @method FS.Utility.getFileExtension\n * @public\n * @param {String} name - A filename, filepath, or URL that may or may not have an extension.\n * @returns {String} The extension or an empty string if no extension found.\n */\nFS.Utility.getFileExtension = function utilGetFileExtension(name) {\n  name = FS.Utility.getFileName(name);\n  // Seekout the last '.' if found\n  var found = name.lastIndexOf('.');\n  // Return the extension if found else ''\n  // If found is -1, we return '' because there is no extension\n  // If found is 0, we return '' because it's a hidden file\n  return (found > 0 ? name.slice(found + 1).toLowerCase() : '');\n};\n\n/**\n * @method FS.Utility.setFileExtension\n * @public\n * @param {String} name - A filename that may or may not already have an extension.\n * @param {String} ext - An extension without leading period, which you want to be the new extension on `name`.\n * @returns {String} The filename with changed extension.\n */\nFS.Utility.setFileExtension = function utilSetFileExtension(name, ext) {\n  if (!name || !name.length) {\n    return name;\n  }\n  var currentExt = FS.Utility.getFileExtension(name);\n  if (currentExt.length) {\n    name = name.slice(0, currentExt.length * -1) + ext;\n  } else {\n    name = name + '.' + ext;\n  }\n  return name;\n};\n\n/*\n * Borrowed these from http package\n */\nFS.Utility.encodeParams = function encodeParams(params) {\n  var buf = [];\n  _.each(params, function(value, key) {\n    if (buf.length)\n      buf.push('&');\n    buf.push(FS.Utility.encodeString(key), '=', FS.Utility.encodeString(value));\n  });\n  return buf.join('').replace(/%20/g, '+');\n};\n\nFS.Utility.encodeString = function encodeString(str) {\n  return encodeURIComponent(str).replace(/[!'()]/g, escape).replace(/\\*/g, \"%2A\");\n};\n\n/*\n * btoa and atob shims for client and server\n */\n\nFS.Utility._btoa = function _fsUtility_btoa(str) {\n  var buffer;\n\n  if (str instanceof Buffer) {\n    buffer = str;\n  } else {\n    buffer = new Buffer(str.toString(), 'binary');\n  }\n\n  return buffer.toString('base64');\n};\n\nFS.Utility.btoa = function fsUtility_btoa(str) {\n  if (typeof btoa === 'function') {\n    // Client\n    return btoa(str);\n  } else if (typeof Buffer !== 'undefined') {\n    // Server\n    return FS.Utility._btoa(str);\n  } else {\n    throw new Error('FS.Utility.btoa: Cannot base64 encode on your system');\n  }\n};\n\nFS.Utility._atob = function _fsUtility_atob(str) {\n  return new Buffer(str, 'base64').toString('binary');\n};\n\nFS.Utility.atob = function fsUtility_atob(str) {\n  if (typeof atob === 'function') {\n    // Client\n    return atob(str);\n  } else if (typeof Buffer !== 'undefined') {\n    // Server\n    return FS.Utility._atob(str);\n  } else {\n    throw new Error('FS.Utility.atob: Cannot base64 encode on your system');\n  }\n};\n\n// Api wrap for 3party libs like underscore\nFS.Utility.extend = _.extend;\n\nFS.Utility.each = _.each;\n\nFS.Utility.isEmpty = _.isEmpty;\n\nFS.Utility.indexOf = _.indexOf;\n\nFS.Utility.isArray = _.isArray;\n\nFS.Utility.map = _.map;\n\nFS.Utility.once = _.once;\n\nFS.Utility.include = _.include;\n\nFS.Utility.size = _.size;\n","/**\n * @method FS.Utility.binaryToBuffer\n * @public\n * @param {Uint8Array} data\n * @returns {Buffer}\n *\n * Converts a Uint8Array instance to a Node Buffer instance\n */\nFS.Utility.binaryToBuffer = function(data) {\n  var len = data.length;\n  var buffer = new Buffer(len);\n  for (var i = 0; i < len; i++) {\n    buffer[i] = data[i];\n  }\n  return buffer;\n};\n\n/**\n * @method FS.Utility.bufferToBinary\n * @public\n * @param {Buffer} data\n * @returns {Uint8Array}\n *\n * Converts a Node Buffer instance to a Uint8Array instance\n */\nFS.Utility.bufferToBinary = function(data) {\n  var len = data.length;\n  var binary = EJSON.newBinary(len);\n  for (var i = 0; i < len; i++) {\n    binary[i] = data[i];\n  }\n  return binary;\n};\n\nFS.Utility.safeCallback = function (callback) {\n    // Make callback safe for Meteor code\n    return Meteor.bindEnvironment(callback, function(err) { throw err; });\n};\n\nFS.Utility.safeStream = function(nodestream, name) {\n  if (!nodestream || typeof nodestream.on !== 'function')\n    throw new Error('Storage Adapter \"' + name + '\" did not return write stream');\n\n  // Create Meteor safe events\n  nodestream.safeOn = function(name, callback) {\n    return nodestream.on(name, FS.Utility.safeCallback(callback));\n  };\n\n  // Create Meteor safe events\n  nodestream.safeOnce = function(name, callback) {\n    return nodestream.once(name, FS.Utility.safeCallback(callback));\n  };\n\n  // Return the modified stream - modified anyway\n  return nodestream;\n};\n"]}