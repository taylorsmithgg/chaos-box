{"version":3,"file":"/packages/cfs:power-queue.js","sources":["cfs:power-queue/power-queue.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAAA,wB;AACA,kE;AACA,iD;AACA,C;AACA,sE;AACA,uD;AACA,C;;AAEA,kC;AACA,sE;AACA,qD;AACA,C;AACA,0E;AACA,2D;AACA,C;;AAEA,G;AACA,iE;AACA,wD;AACA,E;AACA,e;AACA,mB;AACA,qC;AACA,0E;AACA,6D;AACA,8E;AACA,2D;AACA,+E;AACA,oH;AACA,+F;AACA,6E;AACA,4F;AACA,gF;AACA,0E;AACA,6E;AACA,sE;AACA,8J;AACA,G;AACA,gC;AACA,kB;AACA,e;;AAEA,0E;;AAEA,6C;AACA,yE;AACA,mF;;AAEA,wE;AACA,qF;;AAEA,iF;AACA,8D;AACA,sC;AACA,G;;AAEA,2C;AACA,wE;AACA,4E;AACA,0G;AACA,G;;AAEA,yB;AACA,sC;AACA,M;AACA,sD;AACA,2B;AACA,K;AACA,wD;;AAEA,0C;AACA,uC;AACA,2B;AACA,uB;;AAEA,qD;AACA,mG;;AAEA,6C;AACA,8D;;AAEA,iD;AACA,6F;;AAEA,8E;AACA,6D;;AAEA,uE;AACA,wD;;AAEA,oD;AACA,0D;;AAEA,iF;AACA,oF;;AAEA,6B;AACA,2D;;AAEA,+E;AACA,oH;;AAEA,wF;AACA,kG;;AAEA,6D;AACA,kD;;AAEA,uD;AACA,4C;;AAEA,8B;AACA,c;AACA,oE;AACA,K;AACA,mC;;AAEA,iC;AACA,c;AACA,+D;AACA,K;AACA,mC;;AAEA,mC;AACA,c;AACA,gE;AACA,K;AACA,2C;;AAEA,+B;AACA,c;AACA,iD;AACA,gF;AACA,K;AACA,iC;;AAEA,iC;AACA,c;AACA,uD;AACA,K;AACA,qC;;AAEA,kC;AACA,c;AACA,oD;AACA,yD;AACA,K;AACA,qC;;AAEA,mE;AACA,sE;AACA,c;AACA,sE;AACA,I;AACA,a;AACA,U;AACA,iF;AACA,2D;AACA,Q;AACA,K;AACA,kD;;AAEA,6C;AACA,8E;AACA,6B;AACA,4B;AACA,+B;AACA,8B;AACA,I;;AAEA,2D;AACA,2E;AACA,c;AACA,uE;AACA,I;AACA,a;AACA,U;AACA,6E;AACA,2D;AACA,Q;AACA,K;AACA,0C;;AAEA,+D;AACA,sE;AACA,c;AACA,mF;AACA,I;AACA,a;AACA,U;AACA,+E;AACA,yD;AACA,Q;AACA,K;AACA,8C;;AAEA,mC;AACA,kC;AACA,K;AACA,6D;AACA,qD;AACA,I;;AAEA,kC;AACA,kC;AACA,K;AACA,2D;AACA,qD;AACA,I;;AAEA,oC;AACA,qC;AACA,K;AACA,+D;AACA,wD;AACA,I;;AAEA,sC;AACA,yC;AACA,K;AACA,mE;AACA,yD;AACA,I;AACA,E;;AAEA,8C;AACA,c;AACA,6D;AACA,K;AACA,oD;AACA,oB;AACA,qC;AACA,I;;AAEA,2C;AACA,c;AACA,kE;AACA,K;AACA,8C;AACA,oB;AACA,wD;AACA,I;;AAEA,yC;AACA,c;AACA,oE;AACA,K;AACA,4C;AACA,oB;AACA,qC;AACA,I;;AAEA,2C;AACA,c;AACA,mE;AACA,K;AACA,8C;AACA,oB;AACA,gG;AACA,oC;AACA,gE;AACA,K;AACA,a;AACA,I;;AAEA,wC;AACA,c;AACA,uE;AACA,K;AACA,2C;AACA,oB;AACA,kF;AACA,I;;AAEA,wD;AACA,uB;AACA,qB;AACA,sB;AACA,6B;AACA,I;AACA,4E;AACA,+E;AACA,wE;AACA,K;AACA,2C;AACA,oB;AACA,qD;AACA,6B;AACA,4B;AACA,6B;AACA,8B;;AAEA,2D;AACA,iD;AACA,gD;AACA,8B;AACA,U;AACA,gB;AACA,2B;AACA,0B;AACA,wB;AACA,I;;AAEA,wC;AACA,a;AACA,I;AACA,gF;AACA,iD;AACA,K;AACA,qD;AACA,oB;;AAEA,4D;AACA,8B;;AAEA,+E;AACA,0D;AACA,mC;AACA,2B;AACA,+B;AACA,gC;AACA,O;;AAEA,sD;AACA,gC;AACA,0C;AACA,wB;AACA,O;;AAEA,K;AACA,I;;AAEA,sC;AACA,6C;AACA,8E;AACA,K;AACA,2D;AACA,oB;;AAEA,4B;AACA,uE;;AAEA,sB;AACA,gE;;AAEA,+F;AACA,0F;;AAEA,iD;AACA,2C;;AAEA,2B;AACA,I;;AAEA,mD;AACA,a;AACA,I;AACA,4E;AACA,I;AACA,4E;AACA,sE;AACA,K;AACA,sD;AACA,oB;;AAEA,+C;AACA,8E;AACA,+E;AACA,2G;AACA,oE;AACA,+B;AACA,iB;AACA,oD;AACA,oF;AACA,8B;AACA,K;;AAEA,I;;AAEA,qD;AACA,a;AACA,I;AACA,2E;AACA,I;AACA,4E;AACA,sE;AACA,K;AACA,wD;AACA,oB;AACA,2E;AACA,oE;;AAEA,qE;AACA,mB;AACA,wC;AACA,uD;AACA,2D;AACA,iB;AACA,sE;AACA,4E;AACA,6B;AACA,S;AACA,e;AACA,K;AACA,I;;AAEA,uC;AACA,uD;AACA,8C;AACA,6D;AACA,0D;AACA,yE;AACA,qD;AACA,K;AACA,6C;AACA,oB;AACA,+D;AACA,4B;AACA,4B;AACA,M;AACA,qD;AACA,4B;;AAEA,4E;AACA,wC;AACA,2C;AACA,qB;AACA,gF;;AAEA,6E;AACA,4E;AACA,8C;AACA,oF;AACA,kD;AACA,+C;;AAEA,gE;AACA,yC;AACA,yB;AACA,iC;AACA,+D;AACA,uB;AACA,O;;AAEA,K;AACA,I;;AAEA,oB;AACA,gH;AACA,I;AACA,+B;AACA,oG;AACA,2E;AACA,mD;AACA,kE;AACA,mC;AACA,iC;AACA,mC;AACA,qC;AACA,I;AACA,K;;;AAGA,8C;AACA,a;AACA,gH;AACA,+B;AACA,I;AACA,8D;AACA,I;AACA,K;AACA,8B;AACA,qE;AACA,oB;;AAEA,yE;AACA,mD;AACA,uE;AACA,wE;AACA,2C;AACA,0D;AACA,6D;AACA,2B;;AAEA,wE;AACA,+F;;AAEA,0D;AACA,yD;AACA,uE;AACA,c;AACA,2B;AACA,0E;AACA,O;;AAEA,wD;AACA,yD;;AAEA,iB;;AAEA,8C;AACA,4B;AACA,4D;AACA,6H;AACA,K;;AAEA,oD;AACA,mC;AACA,qB;AACA,8C;AACA,4C;AACA,8C;AACA,gD;AACA,Q;AACA,oD;AACA,wC;AACA,4B;AACA,c;AACA,yD;AACA,oE;AACA,O;AACA,K;AACA,mD;AACA,mC;AACA,+D;AACA,8D;AACA,6C;;AAEA,2B;AACA,+B;AACA,0B;AACA,sB;AACA,sB;AACA,gB;AACA,kC;AACA,kB;AACA,U;;AAEA,I;;;AAGA,0C;AACA,iD;AACA,oE;AACA,K;AACA,uD;AACA,oB;;AAEA,wC;AACA,gF;AACA,gD;AACA,S;AACA,kD;;AAEA,8C;AACA,iG;AACA,sB;AACA,wF;AACA,iD;AACA,gC;;AAEA,c;;AAEA,wC;AACA,kE;AACA,sB;AACA,+E;AACA,iD;AACA,gC;;AAEA,O;AACA,kB;AACA,0F;AACA,K;AACA,I;;AAEA,mD;AACA,kD;AACA,K;AACA,8E;AACA,oB;AACA,sC;AACA,8C;AACA,yE;AACA,uE;AACA,0B;AACA,8E;AACA,mB;AACA,c;AACA,0B;AACA,qE;AACA,e;AACA,kF;AACA,mD;AACA,O;AACA,M;;AAEA,sB;AACA,mB;AACA,I;;AAEA,gD;AACA,oD;AACA,iE;AACA,6D;AACA,I;AACA,oD;AACA,U;AACA,0D;AACA,gF;AACA,0C;AACA,sE;AACA,U;AACA,c;AACA,yC;AACA,gC;AACA,uB;AACA,qC;AACA,qB;AACA,U;AACA,S;AACA,Q;AACA,K;;AAEA,mC;AACA,qE;AACA,oB;AACA,2E;AACA,qC;AACA,iE;AACA,K;AACA,S;AACA,oC;AACA,2B;AACA,kB;AACA,gC;AACA,gB;AACA,K;AACA,I;;AAEA,iD;AACA,oD;AACA,wF;AACA,6D;AACA,I;AACA,0B;AACA,U;AACA,kC;AACA,I;AACA,sC;AACA,6D;AACA,iF;AACA,wD;AACA,qC;AACA,kE;AACA,S;AACA,Q;AACA,K;AACA,yE;AACA,oB;AACA,4E;AACA,mD;AACA,gC;AACA,wE;AACA,I;;AAEA,wD;AACA,uD;AACA,K;AACA,2C;AACA,oB;AACA,8B;;AAEA,6B;AACA,0D;AACA,gD;AACA,+C;AACA,gC;AACA,6B;AACA,S;AACA,e;;AAEA,yB;AACA,sB;AACA,K;AACA,I;;AAEA,8D;AACA,wD;AACA,I;AACA,0C;AACA,K;AACA,4C;AACA,oB;AACA,e;AACA,I;;AAEA,uD;AACA,6D;AACA,6B;AACA,K;AACA,yC;AACA,oB;AACA,uE;AACA,kF;AACA,a;AACA,K;;AAEA,4B;AACA,4B;AACA,oB;AACA,I;;AAEA,uD;AACA,K;AACA,0C;AACA,oB;AACA,6B;AACA,I;;AAEA,0D;AACA,K;AACA,4C;AACA,oB;AACA,iB;AACA,I","sourcesContent":["// Rig weak dependencies\nif (typeof MicroQueue === 'undefined' && Package['micro-queue']) {\n  MicroQueue = Package['micro-queue'].MicroQueue;\n}\nif (typeof ReactiveList === 'undefined' && Package['reactive-list']) {\n  ReactiveList = Package['reactive-list'].ReactiveList;\n}\n\n// Rig weak dependencies in +0.9.1\nif (typeof MicroQueue === 'undefined' && Package['cfs:micro-queue']) {\n  MicroQueue = Package['cfs:micro-queue'].MicroQueue;\n}\nif (typeof ReactiveList === 'undefined' && Package['cfs:reactive-list']) {\n  ReactiveList = Package['cfs:reactive-list'].ReactiveList;\n}\n\n/**\n * Creates an instance of a power queue // Testing inline comment\n * [Check out demo](http://power-queue-test.meteor.com/)\n *\n * @constructor\n * @self powerqueue\n * @param {object} [options] Settings\n * @param {boolean} [options.filo=false] Make it a first in last out queue\n * @param {boolean} [options.isPaused=false] Set queue paused\n * @param {boolean} [options.autostart=true] May adding a task start the queue\n * @param {string} [options.name=\"Queue\"] Name of the queue\n * @param {number} [options.maxProcessing=1] Limit of simultanous running tasks\n * @param {number} [options.maxFailures = 5] Limit retries of failed tasks, if 0 or below we allow infinite failures\n * @param {number} [options.jumpOnFailure = true] Jump to next task and retry failed task later\n * @param {boolean} [options.debug=false] Log verbose messages to the console\n * @param {boolean} [options.reactive=true] Set whether or not this queue should be reactive\n * @param {boolean} [options.onAutostart] Callback for the queue autostart event\n * @param {boolean} [options.onPaused] Callback for the queue paused event\n * @param {boolean} [options.onReleased] Callback for the queue release event\n * @param {boolean} [options.onEnded] Callback for the queue end event\n * @param {[SpinalQueue](spinal-queue.spec.md)} [options.spinalQueue] Set spinal queue uses pr. default `MicroQueue` or `ReactiveList` if added to the project\n */\nPowerQueue = function(options) {\n  var self = this;\n  var test = 5;\n\n  self.reactive = (options && options.reactive === false) ? false :  true;\n\n  // Allow user to use another micro-queue #3\n  // We try setting the ActiveQueue to MicroQueue if installed in the app\n  var ActiveQueue = (typeof MicroQueue !== 'undefined') && MicroQueue || undefined;\n\n  // If ReactiveList is added to the project we use this over MicroQueue\n  ActiveQueue = (typeof ReactiveList !== 'undefined') && ReactiveList || ActiveQueue;\n\n  // We allow user to overrule and set a custom spinal-queue spec complient queue\n  if (options && typeof options.spinalQueue !== 'undefined') {\n    ActiveQueue = options.spinalQueue;\n  }\n\n  if (typeof ActiveQueue === 'undefined') {\n    console.log('Error: You need to add a spinal queue to the project');\n    console.log('Please add \"micro-queue\", \"reactive-list\" to the project');\n    throw new Error('Please add \"micro-queue\", \"reactive-list\" or other spinalQueue compatible packages');\n  }\n\n  // Default is fifo lilo\n  self.invocations = new ActiveQueue({\n    //\n    sort: (options && (options.filo || options.lifo)),\n    reactive: self.reactive\n  });\n  //var self.invocations = new ReactiveList(queueOrder);\n\n  // List of current tasks being processed\n  self._processList = new ActiveQueue({\n    reactive: self.reactive\n  }); //ReactiveList();\n\n  // Max number of simultanious tasks being processed\n  self._maxProcessing = new ReactiveProperty(options && options.maxProcessing || 1, self.reactive);\n\n  // Reactive number of tasks being processed\n  self._isProcessing = new ReactiveProperty(0, self.reactive);\n\n  // Boolean indicating if queue is paused or not\n  self._paused = new ReactiveProperty((options && options.isPaused || false), self.reactive);\n\n  // Boolean indicator for queue status active / running (can still be paused)\n  self._running = new ReactiveProperty(false, self.reactive);\n\n  // Counter for errors, errors are triggered if maxFailures is exeeded\n  self._errors = new ReactiveProperty(0, self.reactive);\n\n  // Counter for task failures, contains error count\n  self._failures = new ReactiveProperty(0, self.reactive);\n\n  // On failure jump to new task - if false the current task is rerun until error\n  self._jumpOnFailure = (options && options.jumpOnFailure === false) ? false : true;\n\n  // Count of all added tasks\n  self._maxLength = new ReactiveProperty(0, self.reactive);\n\n  // Boolean indicate whether or not a \"add\" task is allowed to start the queue\n  self._autostart = new ReactiveProperty( ((options && options.autostart === false) ? false : true), self.reactive);\n\n  // Limit times a task is allowed to fail and be rerun later before triggering an error\n  self._maxFailures = new ReactiveProperty( (options && options.maxFailures || 5), self.reactive);\n\n  // Name / title of this queue - Not used - should deprecate\n  self.title = options && options.name || 'Queue';\n\n  // debug - will print error / failures passed to next\n  self.debug = !!(options && options.debug);\n\n  /** @method PowerQueue.total\n   * @reactive\n   * @returns {number} The total number of tasks added to this queue\n   */\n  self.total = self._maxLength.get;\n\n  /** @method PowerQueue.isPaused\n   * @reactive\n   * @returns {boolean} Status of the paused state of the queue\n   */\n  self.isPaused = self._paused.get;\n\n  /** @method PowerQueue.processing\n   * @reactive\n   * @returns {number} Number of tasks currently being processed\n   */\n  self.processing = self._isProcessing.get;\n\n  /** @method PowerQueue.errors\n   * @reactive\n   * @returns {number} The total number of errors\n   * Errors are triggered when [maxFailures](PowerQueue.maxFailures) are exeeded\n   */\n  self.errors = self._errors.get;\n\n  /** @method PowerQueue.failures\n   * @reactive\n   * @returns {number} The total number of failed tasks\n   */\n  self.failures = self._failures.get;\n\n  /** @method PowerQueue.isRunning\n   * @reactive\n   * @returns {boolean} True if the queue is running\n   * > NOTE: The task can be paused but marked as running\n   */\n  self.isRunning = self._running.get;\n\n  /** @method PowerQueue.maxProcessing Get setter for maxProcessing\n   * @param {number} [max] If not used this function works as a getter\n   * @reactive\n   * @returns {number} Maximum number of simultaneous processing tasks\n   *\n   * Example:\n   * ```js\n   *   foo.maxProcessing();    // Works as a getter and returns the current value\n   *   foo.maxProcessing(20);  // This sets the value to 20\n   * ```\n   */\n  self.maxProcessing = self._maxProcessing.getset;\n\n  self._maxProcessing.onChange = function() {\n    // The user can change the max allowed processing tasks up or down here...\n    // Update the throttle up\n    self.updateThrottleUp();\n    // Update the throttle down\n    self.updateThrottleDown();\n  };\n\n  /** @method PowerQueue.autostart Get setter for autostart\n   * @param {boolean} [autorun] If not used this function works as a getter\n   * @reactive\n   * @returns {boolean} If adding a task may trigger the queue to start\n   *\n   * Example:\n   * ```js\n   *   foo.autostart();    // Works as a getter and returns the current value\n   *   foo.autostart(true);  // This sets the value to true\n   * ```\n   */\n  self.autostart = self._autostart.getset;\n\n  /** @method PowerQueue.maxFailures Get setter for maxFailures\n   * @param {number} [max] If not used this function works as a getter\n   * @reactive\n   * @returns {number} The maximum for failures pr. task before triggering an error\n   *\n   * Example:\n   * ```js\n   *   foo.maxFailures();    // Works as a getter and returns the current value\n   *   foo.maxFailures(10);  // This sets the value to 10\n   * ```\n   */\n  self.maxFailures = self._maxFailures.getset;\n\n  /** @callback PowerQueue.onPaused\n   * Is called when queue is ended\n   */\n  self.onPaused = options && options.onPaused || function() {\n    self.debug && console.log(self.title + ' ENDED');\n  };\n\n  /** @callback PowerQueue.onEnded\n   * Is called when queue is ended\n   */\n  self.onEnded = options && options.onEnded || function() {\n    self.debug && console.log(self.title + ' ENDED');\n  };\n\n  /** @callback PowerQueue.onRelease\n   * Is called when queue is released\n   */\n  self.onRelease = options && options.onRelease || function() {\n    self.debug && console.log(self.title + ' RELEASED');\n  };\n\n  /** @callback PowerQueue.onAutostart\n   * Is called when queue is auto started\n   */\n  self.onAutostart = options && options.onAutostart || function() {\n    self.debug && console.log(self.title + ' Autostart');\n  };\n};\n\n  /** @method PowerQueue.prototype.processList\n   * @reactive\n   * @returns {array} List of tasks currently being processed\n   */\n  PowerQueue.prototype.processingList = function() {\n    var self = this;\n    return self._processList.fetch();\n  };\n\n  /** @method PowerQueue.prototype.isHalted\n   * @reactive\n   * @returns {boolean} True if the queue is not running or paused\n   */\n  PowerQueue.prototype.isHalted = function() {\n    var self = this;\n    return (!self._running.get() || self._paused.get());\n  };\n\n  /** @method PowerQueue.prototype.length\n   * @reactive\n   * @returns {number} Number of tasks left in queue to be processed\n   */\n  PowerQueue.prototype.length = function() {\n    var self = this;\n    return self.invocations.length();\n  };\n\n  /** @method PowerQueue.prototype.progress\n   * @reactive\n   * @returns {number} 0 .. 100 % Indicates the status of the queue\n   */\n  PowerQueue.prototype.progress = function() {\n    var self = this;\n    var progress = self._maxLength.get() - self.invocations.length() - self._isProcessing.get();\n    if (self._maxLength.value > 0) {\n      return Math.round(progress / self._maxLength.value * 100);\n    }\n    return 0;\n  };\n\n  /** @method PowerQueue.prototype.usage\n   * @reactive\n   * @returns {number} 0 .. 100 % Indicates resource usage of the queue\n   */\n  PowerQueue.prototype.usage = function() {\n    var self = this;\n    return Math.round(self._isProcessing.get() / self._maxProcessing.get() * 100);\n  };\n\n  /** @method PowerQueue.prototype.reset Reset the queue\n   * Calling this will:\n   * * stop the queue\n   * * paused to false\n   * * Discart all queue data\n   *\n   * > NOTE: At the moment if the queue has processing tasks they can change\n   * > the `errors` and `failures` counters. This could change in the future or\n   * > be prevented by creating a whole new instance of the `PowerQueue`\n   */\n  PowerQueue.prototype.reset = function() {\n    var self = this;\n    self.debug && console.log(self.title + ' RESET');\n    self._running.set(false);\n    self._paused.set(false);\n    self.invocations.reset();\n    self._processList.reset();\n\n    // // Loop through the processing tasks and reset these\n    // self._processList.forEach(function(data) {\n    //   if (data.queue instanceof PowerQueue) {\n    //     data.queue.reset();\n    //   }\n    // }, true);\n    self._maxLength.set(0);\n    self._failures.set(0);\n    self._errors.set(0);\n  };\n\n  /** @method PowerQueue._autoStartTasks\n   * @private\n   *\n   * This method defines the autostart algorithm that allows add task to trigger\n   * a start of the queue if queue is not paused.\n   */\n  PowerQueue.prototype._autoStartTasks = function() {\n    var self = this;\n\n    // We dont start anything by ourselfs if queue is paused\n    if (!self._paused.value) {\n\n      // Queue is not running and we are set to autostart so we start the queue\n      if (!self._running.value && self._autostart.value) {\n        // Trigger callback / event\n        self.onAutostart();\n        // Set queue as running\n        self._running.set(true);\n      }\n\n      // Make sure that we use all available resources\n      if (self._running.value) {\n        // Call next to start up the queue\n        self.next(null);\n      }\n\n    }\n  };\n\n  /** @method PowerQueue.prototype.add\n   * @param {any} data The task to be handled\n   * @param {number} [failures] Used internally to Pass on number of failures.\n   */\n  PowerQueue.prototype.add = function(data, failures, id) {\n    var self = this;\n\n    // Assign new id to task\n    var assignNewId = self._jumpOnFailure || typeof id === 'undefined';\n\n    // Set the task id\n    var taskId = (assignNewId) ? self._maxLength.value + 1 : id;\n\n    // self.invocations.add({ _id: currentId, data: data, failures: failures || 0 }, reversed);\n    self.invocations.insert(taskId, { _id: taskId, data: data, failures: failures || 0 });\n\n    // If we assigned new id then increase length\n    if (assignNewId) self._maxLength.inc();\n\n    self._autoStartTasks();\n  };\n\n  /** @method PowerQueue.prototype.updateThrottleUp\n   * @private\n   *\n   * Calling this method will update the throttle on the queue adding tasks.\n   *\n   * > Note: Currently we only support the PowerQueue - but we could support\n   * > a more general interface for pauseable tasks or other usecases.\n   */\n  PowerQueue.prototype.updateThrottleUp = function() {\n    var self = this;\n\n    // How many additional tasks can we handle?\n    var availableSlots = self._maxProcessing.value - self._isProcessing.value;\n    // If we can handle more, we have more, we're running, and we're not paused\n    if (!self._paused.value && self._running.value && availableSlots > 0 && self.invocations._length > 0) {\n      // Increase counter of current number of tasks being processed\n      self._isProcessing.inc();\n      // Run task\n      self.runTask(self.invocations.getFirstItem());\n      // Repeat recursively; this is better than a for loop to avoid blocking the UI\n      self.updateThrottleUp();\n    }\n\n  };\n\n  /** @method PowerQueue.prototype.updateThrottleDown\n   * @private\n   *\n   * Calling this method will update the throttle on the queue pause tasks.\n   *\n   * > Note: Currently we only support the PowerQueue - but we could support\n   * > a more general interface for pauseable tasks or other usecases.\n   */\n  PowerQueue.prototype.updateThrottleDown = function() {\n    var self = this;\n    // Calculate the differece between acutuall processing tasks and target\n    var diff = self._isProcessing.value - self._maxProcessing.value;\n\n    // If the diff is more than 0 then we have many tasks processing.\n    if (diff > 0) {\n      // We pause the latest added tasks\n      self._processList.forEachReverse(function(data) {\n        if (diff > 0 && data.queue instanceof PowerQueue) {\n          diff--;\n          // We dont mind calling pause on multiple times on each task\n          // theres a simple check going on preventing any duplicate actions\n          data.queue.pause();\n        }\n      }, true);\n    }\n  };\n\n  /** @method PowerQueue.prototype.next\n   * @param {string} [err] Error message if task failed\n   * > * Can pass in `null` to start the queue\n   * > * Passing in a string to `next` will trigger a failure\n   * > * Passing nothing will simply let the next task run\n   * `next` is handed into the [taskHandler](PowerQueue.taskHandler) as a\n   * callback to mark an error or end of current task\n   */\n  PowerQueue.prototype.next = function(err) {\n    var self = this;\n    // Primary concern is to throttle up because we are either:\n    // 1. Starting the queue\n    // 2. Starting next task\n    //\n    // This function does not shut down running tasks\n    self.updateThrottleUp();\n\n    // We are running, no tasks are being processed even we just updated the\n    // throttle up and we got no errors.\n    // 1. We are paused and releasing tasks\n    // 2. We are done\n    if (self._running.value && self._isProcessing.value === 0 && err !== null) {\n\n      // We have no tasks processing so this queue is now releasing resources\n      // this could be that the queue is paused or stopped, in that case the\n      // self.invocations._length would be > 0\n      // If on the other hand the self.invocations._length is 0 then we have no more\n      // tasks in the queue so the queue has ended\n      self.onRelease(self.invocations._length);\n\n      if (!self.invocations._length) { // !self._paused.value &&\n        // Check if queue is done working\n        // Stop the queue\n        self._running.set(false);\n        // self.invocations.reset(); // This should be implicit\n        self.onEnded();\n      }\n\n    }\n  };\n\n  /** @callback done\n   * @param {Meteor.Error | Error | String | null} [feedback] This allows the task to communicate with the queue\n   *\n   * Explaination of `feedback`\n   * * `Meteor.Error` This means that the task failed in a controlled manner and is allowed to rerun\n   * * `Error` This will throw the passed error - as its an unitended error\n   * * `null` The task is not done yet, rerun later\n   * * `String` The task can perform certain commands on the queue\n   *    * \"pause\" - pause the queue\n   *    * \"stop\" - stop the queue\n   *    * \"reset\" - reset the queue\n   *    * \"cancel\" - cancel the queue\n   *\n   */\n\n\n  /** @method PowerQueue.prototype.runTaskDone\n   * @private\n   * @param {Meteor.Error | Error | String | null} [feedback] This allows the task to communicate with the queue\n   * @param {object} invocation\n   *\n   * > Note: `feedback` is explained in [Done callback](#done)\n   *\n   */\n  // Rig the callback function\n  PowerQueue.prototype.runTaskDone = function(feedback, invocation) {\n    var self = this;\n\n    // If the task handler throws an error then add it to the queue again\n    // we allow this for a max of self._maxFailures\n    // If the error is null then we add the task silently back into the\n    // microQueue in reverse... This could be due to pause or throttling\n    if (feedback instanceof Meteor.Error) {\n      // We only count failures if maxFailures are above 0\n      if (self._maxFailures.value > 0) invocation.failures++;\n      self._failures.inc();\n\n      // If the user has set the debug flag we print out failures/errors\n      console.error('Error: \"' + self.title + '\" ' + feedback.message + ', ' + feedback.stack);\n\n      if (invocation.failures < self._maxFailures.value) {\n        // Add the task again with the increased failures\n        self.add(invocation.data, invocation.failures, invocation._id);\n      } else {\n        self._errors.inc();\n        self.errorHandler(invocation.data, self.add, invocation.failures);\n      }\n\n      // If a error is thrown we assume its not intended\n    } else if (feedback instanceof Error) throw feedback;\n\n    if (feedback)\n\n    // We use null to throttle pauseable tasks\n    if (feedback === null) {\n      // We add this task into the queue, no questions asked\n      self.invocations.insert(invocation._id, { data: invocation.data, failures: invocation.failures, _id: invocation._id });\n    }\n\n    // If the user returns a string we got a command\n    if (feedback === ''+feedback) {\n      var command = {\n        'pause': function() { self.pause(); },\n        'stop': function() { self.stop(); },\n        'reset': function() { self.reset(); },\n        'cancel': function() { self.cancel(); },\n      };\n      if (typeof command[feedback] === 'function') {\n        // Run the command on this queue\n        command[feedback]();\n      } else {\n        // We dont recognize this command, throw an error\n        throw new Error('Unknown queue command \"' + feedback + '\"');\n      }\n    }\n    // Decrease the number of tasks being processed\n    // make sure we dont go below 0\n    if (self._isProcessing.value > 0) self._isProcessing.dec();\n    // Task has ended we remove the task from the process list\n    self._processList.remove(invocation._id);\n\n    invocation.data = null;\n    invocation.failures = null;\n    invocation._id = null;\n    invocation = null;\n    delete invocation;\n    // Next task\n    Meteor.setTimeout(function() {\n      self.next();\n    }, 0);\n\n  };\n\n\n  /** @method PowerQueue.prototype.runTask\n   * @private // This is not part of the open api\n   * @param {object} invocation The object stored in the micro-queue\n   */\n  PowerQueue.prototype.runTask = function(invocation) {\n    var self = this;\n\n    // We start the fitting task handler\n    // Currently we only support the PowerQueue but we could have a more general\n    // interface for tasks that allow throttling\n    try {\n      if (invocation.data instanceof PowerQueue) {\n\n        // Insert PowerQueue into process list\n        self._processList.insert(invocation._id, { id: invocation._id, queue: invocation.data });\n        // Handle task\n        self.queueTaskHandler(invocation.data, function subQueueCallbackDone(feedback) {\n          self.runTaskDone(feedback, invocation);\n        }, invocation.failures);\n\n      } else {\n\n        // Insert task into process list\n        self._processList.insert(invocation._id, invocation.data);\n        // Handle task\n        self.taskHandler(invocation.data, function taskCallbackDone(feedback) {\n          self.runTaskDone(feedback, invocation);\n        }, invocation.failures);\n\n      }\n    } catch(err) {\n      throw new Error('Error while running taskHandler for queue, Error: ' + err.message);\n    }\n  };\n\n  /** @method PowerQueue.prototype.queueTaskHandler\n   * This method handles tasks that are sub queues\n   */\n  PowerQueue.prototype.queueTaskHandler = function(subQueue, next, failures) {\n    var self = this;\n    // Monitor sub queue task releases\n    subQueue.onRelease = function(remaining) {\n      // Ok, we were paused - this could be throttling so we respect this\n      // So when the queue is halted we add it back into the main queue\n      if (remaining > 0) {\n        // We get out of the queue but dont repport error and add to run later\n        next(null);\n      } else {\n        // Queue has ended\n        // We simply trigger next task when the sub queue is complete\n        next();\n        // When running subqueues it doesnt make sense to track failures and retry\n        // the sub queue - this is sub queue domain\n      }\n    };\n\n    // Start the queue\n    subQueue.run();\n  };\n\n  /** @callback PowerQueue.prototype.taskHandler\n   * @param {any} data This can be data or functions\n   * @param {function} next Function `next` call this to end task\n   * @param {number} failures Number of failures on this task\n   *\n   * Default task handler expects functions as data:\n   * ```js\n   *   self.taskHandler = function(data, next, failures) {\n   *     // This default task handler expects invocation to be a function to run\n   *     if (typeof data !== 'function') {\n   *       throw new Error('Default task handler expects a function');\n   *     }\n   *     try {\n   *       // Have the function call next\n   *       data(next, failures);\n   *     } catch(err) {\n   *       // Throw to fail this task\n   *       next(err);\n   *     }\n   *   };\n   * ```\n   */\n\n  // Can be overwrittin by the user\n  PowerQueue.prototype.taskHandler = function(data, next, failures) {\n    var self = this;\n    // This default task handler expects invocation to be a function to run\n    if (typeof data !== 'function') {\n      throw new Error('Default task handler expects a function');\n    }\n    try {\n      // Have the function call next\n      data(next, failures);\n    } catch(err) {\n      // Throw to fail this task\n      next(err);\n    }\n  };\n\n  /** @callback PowerQueue.prototype.errorHandler\n   * @param {any} data This can be data or functions\n   * @param {function} addTask Use this function to insert the data into the queue again\n   * @param {number} failures Number of failures on this task\n   *\n   * The default callback:\n   * ```js\n   *   var foo = new PowerQueue();\n   *\n   *   // Overwrite the default action\n   *   foo.errorHandler = function(data, addTask, failures) {\n   *     // This could be overwritten the data contains the task data and addTask\n   *     // is a helper for adding the task to the queue\n   *     // try again: addTask(data);\n   *     // console.log('Terminate at ' + failures + ' failures');\n   *   };\n   * ```\n   */\n  PowerQueue.prototype.errorHandler = function(data, addTask, failures) {\n    var self = this;\n    // This could be overwritten the data contains the task data and addTask\n    // is a helper for adding the task to the queue\n    // try again: addTask(data);\n    self.debug && console.log('Terminate at ' + failures + ' failures');\n  };\n\n  /** @method PowerQueue.prototype.pause Pause the queue\n   * @todo We should have it pause all processing tasks\n   */\n  PowerQueue.prototype.pause = function() {\n    var self = this;\n    if (!self._paused.value) {\n\n      self._paused.set(true);\n      // Loop through the processing tasks and pause these\n      self._processList.forEach(function(data) {\n        if (data.queue instanceof PowerQueue) {\n          // Pause the sub queue\n          data.queue.pause();\n        }\n      }, true);\n\n      // Trigger callback\n      self.onPaused();\n    }\n  };\n\n  /** @method PowerQueue.prototype.resume Start a paused queue\n   * @todo We should have it resume all processing tasks\n   *\n   * > This will not start a stopped queue\n   */\n  PowerQueue.prototype.resume = function() {\n    var self = this;\n    self.run();\n  };\n\n  /** @method PowerQueue.prototype.run Starts the queue\n   * > Using this command will resume a paused queue and will\n   * > start a stopped queue.\n   */\n  PowerQueue.prototype.run = function() {\n    var self = this;\n    //not paused and already running or queue empty or paused subqueues\n    if (!self._paused.value &&Â self._running.value || !self.invocations._length) {\n      return;\n    }\n\n    self._paused.set(false);\n    self._running.set(true);\n    self.next(null);\n  };\n\n  /** @method PowerQueue.prototype.stop Stops the queue\n   */\n  PowerQueue.prototype.stop = function() {\n    var self = this;\n    self._running.set(false);\n  };\n\n  /** @method PowerQueue.prototype.cancel Cancel the queue\n   */\n  PowerQueue.prototype.cancel = function() {\n    var self = this;\n    self.reset();\n  };\n\n"]}