{"version":3,"sources":["oauth-encryption/encrypt.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA,mC;AACA,qE;AACA,qC;AACA,8B;;AAEA,qB;;AAEA,kB;;;AAGA,qE;AACA,qE;AACA,6C;AACA,E;AACA,gE;AACA,E;AACA,yC;AACA,E;AACA,4C;AACA,kE;AACA,E;;;AAGA,+D;AACA,qB;AACA,E;AACA,oE;AACA,a;AACA,E;AACA,0C;AACA,qB;AACA,kB;AACA,W;AACA,G;;AAEA,uC;AACA,0E;;AAEA,sC;;AAEA,wB;AACA,uF;;AAEA,e;AACA,E;;;AAGA,sE;AACA,sC;AACA,E;AACA,sE;AACA,qE;AACA,8D;AACA,mE;AACA,Q;AACA,E;AACA,2D;AACA,uE;AACA,8B;AACA,E;AACA,gD;AACA,iB;AACA,sD;AACA,G;;AAEA,8C;AACA,e;AACA,kB;AACA,M;AACA,kC;AACA,4E;AACA,U;AACA,8B;AACA,qD;AACA,6B;AACA,+C;AACA,I;AACA,E;;AAEA,oE;AACA,sC;AACA,E;AACA,mE;AACA,6D;AACA,0C;AACA,E;AACA,6D;AACA,kE;AACA,iD;AACA,sD;AACA,e;AACA,sD;;AAEA,O;AACA,iD;AACA,wB;AACA,K;;AAEA,6B;AACA,a;AACA,0C;AACA,kD;AACA,+B;AACA,8C;AACA,M;;AAEA,2B;AACA,wB;AACA,K;;AAEA,Y;AACA,a;;AAEA,S;AACA,sD;AACA,iB;AACA,wB;AACA,K;;AAEA,iC;AACA,wB;AACA,K;;AAEA,c;AACA,gB;AACA,Y;AACA,uB;AACA,K;AACA,e;AACA,yC;AACA,G;AACA,E;;;AAGA,uD;AACA,2B;AACA,oD;AACA,4D;AACA,yD;AACA,0C;AACA,E;;;AAGA,2C;AACA,mB;AACA,E","file":"/packages/oauth-encryption.js","sourcesContent":["var crypto = Npm.require(\"crypto\");\n// XXX We hope to be able to use the `crypto` module exclusively when\n// Node supports GCM in version 0.11.\nvar gcm = NpmModuleNodeAesGcm;\n\nOAuthEncryption = {};\n\nvar gcmKey = null;\n\n\n// Node leniently ignores non-base64 characters when parsing a base64\n// string, but we want to provide a more informative error message if\n// the developer doesn't use base64 encoding.\n//\n// Note that an empty string is valid base64 (denoting 0 bytes).\n//\n// Exported for the convenience of tests.\n//\nOAuthEncryption._isBase64 = function (str) {\n  return _.isString(str) && /^[A-Za-z0-9\\+\\/]*\\={0,2}$/.test(str);\n};\n\n\n// Loads the OAuth secret key, which must be 16 bytes in length\n// encoded in base64.\n//\n// The key may be `null` which reverts to having no key (mainly used\n// by tests).\n//\nOAuthEncryption.loadKey = function (key) {\n  if (key === null) {\n    gcmKey = null;\n    return;\n  }\n\n  if (! OAuthEncryption._isBase64(key))\n    throw new Error(\"The OAuth encryption key must be encoded in base64\");\n\n  var buf = new Buffer(key, \"base64\");\n\n  if (buf.length !== 16)\n    throw new Error(\"The OAuth encryption AES-128-GCM key must be 16 bytes in length\");\n\n  gcmKey = buf;\n};\n\n\n// Encrypt `data`, which may be any EJSON-compatible object, using the\n// previously loaded OAuth secret key.\n//\n// The `userId` argument is optional. The data is encrypted as { data:\n// *, userId: * }. When the result of `seal` is passed to `open`, the\n// same user id must be supplied, which prevents user specific\n// credentials such as access tokens from being used by a different\n// user.\n//\n// We would actually like the user id to be AAD (additional\n// authenticated data), but the node crypto API does not currently have\n// support for specifying AAD.\n//\nOAuthEncryption.seal = function (data, userId) {\n  if (! gcmKey) {\n    throw new Error(\"No OAuth encryption key loaded\");\n  }\n\n  var plaintext = new Buffer(EJSON.stringify({\n    data: data,\n    userId: userId\n  }));\n  var iv = crypto.randomBytes(12);\n  var result = gcm.encrypt(gcmKey, iv, plaintext, new Buffer([]) /* aad */);\n  return {\n    iv: iv.toString(\"base64\"),\n    ciphertext: result.ciphertext.toString(\"base64\"),\n    algorithm: \"aes-128-gcm\",\n    authTag: result.auth_tag.toString(\"base64\")\n  };\n};\n\n// Decrypt the passed ciphertext (as returned from `seal`) using the\n// previously loaded OAuth secret key.\n//\n// `userId` must match the user id passed to `seal`: if the user id\n// wasn't specified, it must not be specified here, if it was\n// specified, it must be the same user id.\n//\n// To prevent an attacker from breaking the encryption key by\n// observing the result of sending manipulated ciphertexts, `open`\n// throws \"decryption unsuccessful\" on any error.\nOAuthEncryption.open = function (ciphertext, userId) {\n  if (! gcmKey)\n    throw new Error(\"No OAuth encryption key loaded\");\n\n  try {\n    if (ciphertext.algorithm !== \"aes-128-gcm\") {\n      throw new Error();\n    }\n\n    var result = gcm.decrypt(\n      gcmKey,\n      new Buffer(ciphertext.iv, \"base64\"),\n      new Buffer(ciphertext.ciphertext, \"base64\"),\n      new Buffer([]), /* aad */\n      new Buffer(ciphertext.authTag, \"base64\")\n    );\n\n    if (! result.auth_ok) {\n      throw new Error();\n    }\n\n    var err;\n    var data;\n\n    try {\n      data = EJSON.parse(result.plaintext.toString());\n    } catch (e) {\n      err = new Error();\n    }\n\n    if (data.userId !== userId) {\n      err = new Error();\n    }\n\n    if (err) {\n      throw err;\n    } else {\n      return data.data;\n    }\n  } catch (e) {\n    throw new Error(\"decryption failed\");\n  }\n};\n\n\nOAuthEncryption.isSealed = function (maybeCipherText) {\n  return maybeCipherText &&\n    OAuthEncryption._isBase64(maybeCipherText.iv) &&\n    OAuthEncryption._isBase64(maybeCipherText.ciphertext) &&\n    OAuthEncryption._isBase64(maybeCipherText.authTag) &&\n    _.isString(maybeCipherText.algorithm);\n};\n\n\nOAuthEncryption.keyIsLoaded = function () {\n  return !! gcmKey;\n};\n"]}